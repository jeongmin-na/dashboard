---
globs: *.py
description: Python backend patterns and proxy server guidelines
---

# Python Backend Guidelines

## Proxy Server Architecture

The [proxy_server.py](mdc:proxy_server.py) serves as a CORS-enabled proxy between the dashboard and Cursor Admin API.

### Core Structure
```python
class CursorAPIProxy(http.server.SimpleHTTPRequestHandler):
    """Cursor Admin API í”„ë¡ì‹œ í•¸ë“¤ëŸ¬"""
    
    def __init__(self, *args, **kwargs):
        self.api_key = "key_e46368ce482125bbd568b7d55090c657e30e4b73c824f522cbc9ef9b1bf3f0d3"
        self.base_url = "https://api.cursor.com"
        super().__init__(*args, **kwargs)
```

### HTTP Method Handling
```python
def do_OPTIONS(self):
    """CORS preflight ìš”ì²­ ì²˜ë¦¬"""
    self.send_response(200)
    self.send_header('Access-Control-Allow-Origin', '*')
    self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
    self.send_header('Access-Control-Allow-Headers', 'Content-Type, Authorization')
    self.send_header('Access-Control-Max-Age', '86400')
    self.end_headers()

def do_GET(self):
    """GET ìš”ì²­ ì²˜ë¦¬"""
    if self.path.startswith('/teams/'):
        self.handle_api_request('GET')
    else:
        # ì •ì  íŒŒì¼ ì„œë¹™
        super().do_GET()

def do_POST(self):
    """POST ìš”ì²­ ì²˜ë¦¬"""
    if self.path.startswith('/teams/'):
        self.handle_api_request('POST')
    else:
        self.send_error(404, "Not Found")
```

## API Request Handling

### Request Processing Pattern
```python
def handle_api_request(self, method):
    """API ìš”ì²­ ì²˜ë¦¬"""
    try:
        # 1. Read request body
        content_length = int(self.headers.get('Content-Length', 0))
        post_data = None
        if content_length > 0:
            post_data = self.rfile.read(content_length)
        
        # 2. Build API request
        url = f"{self.base_url}{self.path}"
        
        # 3. Setup Basic Auth
        credentials = f"{self.api_key}:"
        encoded_credentials = base64.b64encode(credentials.encode()).decode()
        
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Basic {encoded_credentials}'
        }
        
        # 4. Create request
        if method == 'GET':
            req = urllib.request.Request(url, headers=headers)
        else:  # POST
            req = urllib.request.Request(url, data=post_data, headers=headers, method='POST')
        
        # 5. Make API call and handle response
        with urllib.request.urlopen(req) as response:
            response_data = response.read()
            response_headers = response.headers
            
            # 6. Send response with CORS headers
            self.send_response(response.status)
            self.send_header('Access-Control-Allow-Origin', '*')
            self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
            self.send_header('Access-Control-Allow-Headers', 'Content-Type, Authorization')
            
            # Copy original response headers
            for header, value in response_headers.items():
                if header.lower() not in ['transfer-encoding', 'connection']:
                    self.send_header(header, value)
            
            self.end_headers()
            self.wfile.write(response_data)
            
    except Exception as e:
        self.handle_error(e)
```

## Error Handling

### Exception Handling Pattern
```python
def handle_api_request(self, method):
    try:
        # API request logic
        pass
        
    except HTTPError as e:
        print(f"HTTP ì—ëŸ¬: {e.code} - {e.reason}")
        error_response = {
            'error': 'HTTP Error',
            'code': e.code,
            'message': e.reason
        }
        self.send_error_response(500, json.dumps(error_response))
        
    except URLError as e:
        print(f"URL ì—ëŸ¬: {e.reason}")
        error_response = {
            'error': 'Connection Error',
            'message': str(e.reason)
        }
        self.send_error_response(500, json.dumps(error_response))
        
    except Exception as e:
        print(f"ì˜ˆìƒì¹˜ ëª»í•œ ì—ëŸ¬: {e}")
        error_response = {
            'error': 'Internal Server Error',
            'message': str(e)
        }
        self.send_error_response(500, json.dumps(error_response))

def send_error_response(self, status_code, error_data):
    """ì—ëŸ¬ ì‘ë‹µ ì „ì†¡"""
    self.send_response(status_code)
    self.send_header('Access-Control-Allow-Origin', '*')
    self.send_header('Content-Type', 'application/json')
    self.end_headers()
    self.wfile.write(error_data.encode())
```

## Logging and Debugging

### Request/Response Logging
```python
def handle_api_request(self, method):
    try:
        # Log request
        print(f"í”„ë¡ì‹œ ìš”ì²­: {method} {url}")
        if post_data:
            print(f"ìš”ì²­ ë°ì´í„°: {post_data.decode()}")
        
        # Make API call
        with urllib.request.urlopen(req) as response:
            response_data = response.read()
            
            # Log response
            print(f"API ì‘ë‹µ: {response.status}")
            print(f"ì‘ë‹µ ë°ì´í„°: {response_data.decode()[:200]}...")
            
    except Exception as e:
        print(f"ì—ëŸ¬ ë°œìƒ: {e}")
```

## Server Configuration

### Server Startup
```python
def run_proxy_server(port=8001):
    """í”„ë¡ì‹œ ì„œë²„ ì‹¤í–‰"""
    with socketserver.TCPServer(("", port), CursorAPIProxy) as httpd:
        print(f"ðŸš€ Cursor API í”„ë¡ì‹œ ì„œë²„ê°€ í¬íŠ¸ {port}ì—ì„œ ì‹¤í–‰ ì¤‘ìž…ë‹ˆë‹¤...")
        print(f"ðŸ“Š ëŒ€ì‹œë³´ë“œ ì ‘ì†: http://localhost:{port}/dash.html")
        print("ðŸ›‘ ì„œë²„ë¥¼ ì¤‘ì§€í•˜ë ¤ë©´ Ctrl+Cë¥¼ ëˆ„ë¥´ì„¸ìš”.")
        try:
            httpd.serve_forever()
        except KeyboardInterrupt:
            print("\nðŸ›‘ ì„œë²„ë¥¼ ì¤‘ì§€í•©ë‹ˆë‹¤...")
            httpd.shutdown()

if __name__ == "__main__":
    run_proxy_server()
```

### Port Configuration
- **Default Port**: 8001
- **Access URL**: http://localhost:8001/dash.html
- **API Endpoint**: http://localhost:8001/teams/*

## Security Considerations

### API Key Management
```python
# Store API key securely
self.api_key = "key_e46368ce482125bbd568b7d55090c657e30e4b73c824f522cbc9ef9b1bf3f0d3"

# For production, use environment variables:
import os
self.api_key = os.getenv('CURSOR_API_KEY', 'default_key')
```

### CORS Headers
```python
# Always include CORS headers for frontend compatibility
def add_cors_headers(self):
    self.send_header('Access-Control-Allow-Origin', '*')
    self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
    self.send_header('Access-Control-Allow-Headers', 'Content-Type, Authorization')
    self.send_header('Access-Control-Max-Age', '86400')
```

## Static File Serving

### File Serving Logic
```python
def do_GET(self):
    """GET ìš”ì²­ ì²˜ë¦¬"""
    if self.path.startswith('/teams/'):
        # API requests
        self.handle_api_request('GET')
    else:
        # Static files (HTML, CSS, JS)
        super().do_GET()
```

### Supported File Types
- **HTML**: dash.html (main dashboard)
- **CSS**: Embedded in HTML
- **JavaScript**: Embedded in HTML
- **Static Assets**: Any files in the project directory

## Dependencies Management

### Required Imports
```python
import http.server
import socketserver
import urllib.request
import urllib.parse
import json
import base64
from urllib.error import HTTPError, URLError
import ssl
```

### Requirements File
Maintain [requirements.txt](mdc:requirements.txt) with:
```
urllib3>=1.26.0
json5>=0.9.0
python-dateutil>=2.8.0
pandas>=1.3.0
```

## Development Guidelines

### Code Style
- Use descriptive Korean comments for business logic
- Use English for technical/system comments
- Follow PEP 8 for Python code style
- Use meaningful variable names

### Error Messages
- Provide Korean error messages for user-facing errors
- Use English for technical/debug logs
- Include context in error messages

### Testing Endpoints
```python
# Test endpoints locally
# GET: http://localhost:8001/teams/members
# POST: http://localhost:8001/teams/daily-usage-data
# POST: http://localhost:8001/teams/spend
# POST: http://localhost:8001/teams/filtered-usage-events
```

## Performance Optimization

### Request Handling
- Use connection pooling for multiple requests
- Implement request timeout handling
- Add rate limiting if needed

### Memory Management
- Stream large responses instead of loading into memory
- Clean up resources properly
- Handle connection cleanup

```python
# Example: Streaming large responses
def stream_response(self, response):
    chunk_size = 8192
    while True:
        chunk = response.read(chunk_size)
        if not chunk:
            break
        self.wfile.write(chunk)
```
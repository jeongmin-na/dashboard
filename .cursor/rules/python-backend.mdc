---
globs: *.py
description: Python backend patterns and proxy server guidelines
---

# Python Backend Guidelines

## Proxy Server Architecture

The [proxy_server.py](mdc:proxy_server.py) serves as a CORS-enabled proxy between the dashboard and Cursor Admin API.

### Core Structure
```python
class CursorAPIProxy(http.server.SimpleHTTPRequestHandler):
    """Cursor Admin API 프록시 핸들러"""
    
    def __init__(self, *args, **kwargs):
        self.api_key = "key_e46368ce482125bbd568b7d55090c657e30e4b73c824f522cbc9ef9b1bf3f0d3"
        self.base_url = "https://api.cursor.com"
        super().__init__(*args, **kwargs)
```

### HTTP Method Handling
```python
def do_OPTIONS(self):
    """CORS preflight 요청 처리"""
    self.send_response(200)
    self.send_header('Access-Control-Allow-Origin', '*')
    self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
    self.send_header('Access-Control-Allow-Headers', 'Content-Type, Authorization')
    self.send_header('Access-Control-Max-Age', '86400')
    self.end_headers()

def do_GET(self):
    """GET 요청 처리"""
    if self.path.startswith('/teams/'):
        self.handle_api_request('GET')
    else:
        # 정적 파일 서빙
        super().do_GET()

def do_POST(self):
    """POST 요청 처리"""
    if self.path.startswith('/teams/'):
        self.handle_api_request('POST')
    else:
        self.send_error(404, "Not Found")
```

## API Request Handling

### Request Processing Pattern
```python
def handle_api_request(self, method):
    """API 요청 처리"""
    try:
        # 1. Read request body
        content_length = int(self.headers.get('Content-Length', 0))
        post_data = None
        if content_length > 0:
            post_data = self.rfile.read(content_length)
        
        # 2. Build API request
        url = f"{self.base_url}{self.path}"
        
        # 3. Setup Basic Auth
        credentials = f"{self.api_key}:"
        encoded_credentials = base64.b64encode(credentials.encode()).decode()
        
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Basic {encoded_credentials}'
        }
        
        # 4. Create request
        if method == 'GET':
            req = urllib.request.Request(url, headers=headers)
        else:  # POST
            req = urllib.request.Request(url, data=post_data, headers=headers, method='POST')
        
        # 5. Make API call and handle response
        with urllib.request.urlopen(req) as response:
            response_data = response.read()
            response_headers = response.headers
            
            # 6. Send response with CORS headers
            self.send_response(response.status)
            self.send_header('Access-Control-Allow-Origin', '*')
            self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
            self.send_header('Access-Control-Allow-Headers', 'Content-Type, Authorization')
            
            # Copy original response headers
            for header, value in response_headers.items():
                if header.lower() not in ['transfer-encoding', 'connection']:
                    self.send_header(header, value)
            
            self.end_headers()
            self.wfile.write(response_data)
            
    except Exception as e:
        self.handle_error(e)
```

## Error Handling

### Exception Handling Pattern
```python
def handle_api_request(self, method):
    try:
        # API request logic
        pass
        
    except HTTPError as e:
        print(f"HTTP 에러: {e.code} - {e.reason}")
        error_response = {
            'error': 'HTTP Error',
            'code': e.code,
            'message': e.reason
        }
        self.send_error_response(500, json.dumps(error_response))
        
    except URLError as e:
        print(f"URL 에러: {e.reason}")
        error_response = {
            'error': 'Connection Error',
            'message': str(e.reason)
        }
        self.send_error_response(500, json.dumps(error_response))
        
    except Exception as e:
        print(f"예상치 못한 에러: {e}")
        error_response = {
            'error': 'Internal Server Error',
            'message': str(e)
        }
        self.send_error_response(500, json.dumps(error_response))

def send_error_response(self, status_code, error_data):
    """에러 응답 전송"""
    self.send_response(status_code)
    self.send_header('Access-Control-Allow-Origin', '*')
    self.send_header('Content-Type', 'application/json')
    self.end_headers()
    self.wfile.write(error_data.encode())
```

## Logging and Debugging

### Request/Response Logging
```python
def handle_api_request(self, method):
    try:
        # Log request
        print(f"프록시 요청: {method} {url}")
        if post_data:
            print(f"요청 데이터: {post_data.decode()}")
        
        # Make API call
        with urllib.request.urlopen(req) as response:
            response_data = response.read()
            
            # Log response
            print(f"API 응답: {response.status}")
            print(f"응답 데이터: {response_data.decode()[:200]}...")
            
    except Exception as e:
        print(f"에러 발생: {e}")
```

## Server Configuration

### Server Startup
```python
def run_proxy_server(port=8001):
    """프록시 서버 실행"""
    with socketserver.TCPServer(("", port), CursorAPIProxy) as httpd:
        print(f"🚀 Cursor API 프록시 서버가 포트 {port}에서 실행 중입니다...")
        print(f"📊 대시보드 접속: http://localhost:{port}/dash.html")
        print("🛑 서버를 중지하려면 Ctrl+C를 누르세요.")
        try:
            httpd.serve_forever()
        except KeyboardInterrupt:
            print("\n🛑 서버를 중지합니다...")
            httpd.shutdown()

if __name__ == "__main__":
    run_proxy_server()
```

### Port Configuration
- **Default Port**: 8001
- **Access URL**: http://localhost:8001/dash.html
- **API Endpoint**: http://localhost:8001/teams/*

## Security Considerations

### API Key Management
```python
# Store API key securely
self.api_key = "key_e46368ce482125bbd568b7d55090c657e30e4b73c824f522cbc9ef9b1bf3f0d3"

# For production, use environment variables:
import os
self.api_key = os.getenv('CURSOR_API_KEY', 'default_key')
```

### CORS Headers
```python
# Always include CORS headers for frontend compatibility
def add_cors_headers(self):
    self.send_header('Access-Control-Allow-Origin', '*')
    self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
    self.send_header('Access-Control-Allow-Headers', 'Content-Type, Authorization')
    self.send_header('Access-Control-Max-Age', '86400')
```

## Static File Serving

### File Serving Logic
```python
def do_GET(self):
    """GET 요청 처리"""
    if self.path.startswith('/teams/'):
        # API requests
        self.handle_api_request('GET')
    else:
        # Static files (HTML, CSS, JS)
        super().do_GET()
```

### Supported File Types
- **HTML**: dash.html (main dashboard)
- **CSS**: Embedded in HTML
- **JavaScript**: Embedded in HTML
- **Static Assets**: Any files in the project directory

## Dependencies Management

### Required Imports
```python
import http.server
import socketserver
import urllib.request
import urllib.parse
import json
import base64
from urllib.error import HTTPError, URLError
import ssl
```

### Requirements File
Maintain [requirements.txt](mdc:requirements.txt) with:
```
urllib3>=1.26.0
json5>=0.9.0
python-dateutil>=2.8.0
pandas>=1.3.0
```

## Development Guidelines

### Code Style
- Use descriptive Korean comments for business logic
- Use English for technical/system comments
- Follow PEP 8 for Python code style
- Use meaningful variable names

### Error Messages
- Provide Korean error messages for user-facing errors
- Use English for technical/debug logs
- Include context in error messages

### Testing Endpoints
```python
# Test endpoints locally
# GET: http://localhost:8001/teams/members
# POST: http://localhost:8001/teams/daily-usage-data
# POST: http://localhost:8001/teams/spend
# POST: http://localhost:8001/teams/filtered-usage-events
```

## Performance Optimization

### Request Handling
- Use connection pooling for multiple requests
- Implement request timeout handling
- Add rate limiting if needed

### Memory Management
- Stream large responses instead of loading into memory
- Clean up resources properly
- Handle connection cleanup

```python
# Example: Streaming large responses
def stream_response(self, response):
    chunk_size = 8192
    while True:
        chunk = response.read(chunk_size)
        if not chunk:
            break
        self.wfile.write(chunk)
```
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Samsung AI Experience Group Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #1a1a1a;
            color: #e1e1e1;
            overflow-x: hidden;
        }

        .dashboard-container {
            display: flex;
            height: 100vh;
            align-items: stretch;
        }

        /* 사이드바 스타일 */
        .sidebar {
            width: 250px;
            background-color: #2a2a2a;
            color: #b1b1b1;
            border-right: 1px solid #3a3a3a;
            display: flex;
            flex-direction: column;
        }



        .menu-item {
            display: flex;
            align-items: center;
            padding: 12px 20px;
            color: #b1b1b1;
            text-decoration: none;
            transition: all 0.2s ease;
            font-size: 14px;
            cursor: pointer;
            user-select: none;
        }

        .menu-item:hover {
            background-color: #3a3a3a;
            color: #fff;
        }

        .menu-item.active {
            background-color: #4a4a4a;
            color: #fff;
        }

        .refresh-button {
            display: flex;
            align-items: center;
            padding: 12px 20px;
            color: #b1b1b1;
            text-decoration: none;
            transition: all 0.2s ease;
            font-size: 14px;
            cursor: pointer;
            user-select: none;
        }

        .refresh-button:hover {
            background-color: #3a3a3a;
            color: #fff;
        }

        .refresh-progress {
            position: absolute;
            bottom: -10px;
            left: 20px;
            right: 20px;
            height: 6px;
            background-color: #2a2a2a;
            border-radius: 3px;
            overflow: hidden;
            display: none;
        }

        .refresh-progress-bar {
            height: 100%;
            background-color: #4a9eff;
            border-radius: 3px;
            width: 0%;
            transition: width 0.3s ease;
        }

        .refresh-button {
            position: relative;
        }

        .menu-icon {
            width: 16px;
            height: 16px;
            margin-right: 12px;
            opacity: 0.7;
        }

        /* 메인 콘텐츠 영역 */
        .main-content {
            flex: 1;
            background-color: #1a1a1a;
            display: flex;
            flex-direction: column;
        }

        .header {
            background-color: #1a1a1a; /* 배경색 검정으로 변경 */
            padding: 20px 30px;
            height: 80px;
            box-sizing: border-box;
            position: relative;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* 헤더 아래 선에 여백 추가 */
        .header::after {
            content: '';
            position: absolute;
            left: 30px;
            right: 30px;
            bottom: 0;
            height: 1px;
            background-color: #3a3a3a;
        }



        .header-left h1 {
            color: #fff;
            font-size: 24px;
            font-weight: 600;
        }

        .content-area {
            padding: 30px;
            min-height: calc(100vh - 80px);
            overflow-y: auto;
        }

        /* 기본 숨김 처리 */
        .content-section {
            display: none;
        }

        .content-section.active {
            display: block;
        }

        /* Overview 페이지 스타일 */
        .overview-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .overview-stat-box {
            background-color: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            padding: 25px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .overview-stat-box:hover {
            background-color: #3a3a3a;
            border-color: #4a4a4a;
        }

        .overview-stat-box.clickable {
            cursor: pointer;
        }

        .overview-stat-box.selected {
            background-color: #3a3a3a;
            border-color: #5a9eff;
            box-shadow: 0 0 10px rgba(90, 158, 255, 0.3);
        }

        .overview-stat-box.selected .stat-number,
        .overview-stat-box.selected .stat-label,
        .overview-stat-box.selected .stat-description {
            color: white;
        }

        .overview-stat-box .stat-number {
            font-size: 36px;
            font-weight: 700;
            color: #fff;
            margin-bottom: 8px;
        }

        .overview-stat-box .stat-label {
            font-size: 16px;
            font-weight: 600;
            color: #e1e1e1;
            margin-bottom: 4px;
        }

        .overview-stat-box .stat-description {
            font-size: 12px;
            color: #b1b1b1;
        }

        .overview-chart-container {
            background-color: #1a1a1a;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .chart-header h3 {
            color: #fff;
            font-size: 18px;
            font-weight: 600;
            background-color: transparent;
        }

        .chart-controls {
            display: flex;
            gap: 8px;
        }

        .chart-btn {
            background-color: #3a3a3a;
            border: 1px solid #4a4a4a;
            color: #b1b1b1;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .chart-btn:hover {
            background-color: #4a4a4a;
            color: #fff;
        }

        .chart-btn.active {
            background-color: #4a9eff;
            border-color: #4a9eff;
            color: white;
        }

        .overview-member-details {
            background-color: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            overflow: hidden;
        }

        .member-details-header {
            background-color: #1a1a1a;
            color: #fff;
            padding: 15px 20px;
            margin: 0;
            border-bottom: 1px solid #3a3a3a;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .member-details-header h3 {
            font-size: 18px;
            font-weight: 600;
        }



        .member-list {
            display: grid;
            gap: 0;
        }

        .member-list-header {
            display: grid;
            grid-template-columns: 1.5fr 2fr 1fr 1.5fr 1fr 1fr 1fr;
            gap: 20px;
            padding: 12px 20px;
            background-color: #2a2a2a;
            color: #b1b1b1;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            border-bottom: 2px solid #3a3a3a;
        }

        .member-item {
            display: grid;
            grid-template-columns: 1.5fr 2fr 1fr 1.5fr 1fr 1fr 1fr;
            gap: 20px;
            align-items: center;
            padding: 12px 20px;
            background-color: #1a1a1a;
            border-bottom: 1px solid #3a3a3a;
            font-size: 14px;
        }

        .member-item:hover {
            background-color: #2a2a2a;
        }

        .member-item:last-child {
            border-bottom: none;
        }

        .member-date {
            color: #b1b1b1;
            font-size: 13px;
        }

        .member-email {
            color: #b1b1b1;
        }

        .clickable-email {
            color: #4a9eff;
            cursor: pointer;
            text-decoration: none;
            transition: color 0.2s ease;
        }

        .clickable-email:hover {
            color: #2196f3;
            text-decoration: underline;
        }

        .member-type {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }

        .member-type.active {
            background-color: rgba(76, 175, 80, 0.2);
            color: #4caf50;
        }

        .member-type.inactive {
            background-color: rgba(255, 152, 0, 0.2);
            color: #ff9800;
        }

        .member-kind {
            color: #e1e1e1;
            font-size: 13px;
        }

        .member-request {
            color: #fff;
            font-weight: 500;
        }

        .member-spend {
            color: #4a9eff;
            font-weight: 600;
        }

        /* 활동리스트 페이지네이션 스타일 */
        .activity-pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            padding: 15px 20px;
            background-color: #2a2a2a;
            border-top: 1px solid #3a3a3a;
        }

        .activity-pagination button {
            background: #3a3a3a;
            border: 1px solid #4a4a4a;
            color: #e1e1e1;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .activity-pagination button:hover {
            background: #4a4a4a;
        }

        .activity-pagination button.active {
            background: #4a9eff;
            border-color: #4a9eff;
            color: white;
        }

        .activity-pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .activity-pagination .page-info {
            color: #b1b1b1;
            font-size: 12px;
            margin: 0 10px;
        }

        .activity-page-size-selector {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto;
        }

        .activity-page-size-selector select {
            background: #3a3a3a;
            color: #fff;
            border: 1px solid #4a4a4a;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        
        /* 사용자별 누적 사용량 정보 페이지네이션 스타일 */
        .user-cumulative-pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            padding: 15px 20px;
            background-color: #2a2a2a;
            border-top: 1px solid #3a3a3a;
        }
        
        .user-cumulative-pagination button {
            background: #3a3a3a;
            color: #e1e1e1;
            border: 1px solid #4a4a4a;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }
        
        .user-cumulative-pagination button:hover:not(:disabled) {
            background: #4a4a4a;
            border-color: #5a5a5a;
        }
        
        .user-cumulative-pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .user-cumulative-pagination .page-info {
            color: #b1b1b1;
            font-size: 14px;
            min-width: 120px;
            text-align: center;
        }
        
        .user-cumulative-page-size-selector {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .user-cumulative-page-size-selector select {
            background: #3a3a3a;
            color: #fff;
            border: 1px solid #4a4a4a;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        /* Members 페이지네이션 스타일 (All Raw Events와 동일) */
        #members-pagination button {
            background: #3a3a3a;
            border: 1px solid #4a4a4a;
            color: #e1e1e1;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin: 0 2px;
            transition: all 0.2s ease;
        }

        #members-pagination button:hover {
            background: #4a4a4a;
            border-color: #5a5a5a;
        }

        #members-pagination button.active {
            background: #4a9eff;
            border-color: #4a9eff;
            color: white;
            font-weight: 600;
        }

        #members-pagination span {
            color: #7a7a7a;
            padding: 0 5px;
        }

        /* 필터 및 검색 영역 */
        .filter-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding: 15px 0;
            border-bottom: 1px solid #3a3a3a;
        }

        /* Members 섹션에서 구분선 제거 및 간격 축소 */
        #members .filter-controls {
            border-bottom: none;
            margin-bottom: 15px;
            padding: 10px 0;
        }

        .filter-controls         .chart-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .date-picker {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .date-picker input[type="date"] {
            background-color: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            padding: 8px 12px;
            color: #fff;
            font-size: 14px;
        }

        /* 달력 아이콘 색상 변경 */
        .date-picker input[type="date"]::-webkit-calendar-picker-indicator {
            filter: invert(1) brightness(1.5) sepia(1) saturate(5) hue-rotate(45deg);
            cursor: pointer;
        }

        .date-picker input[type="date"]::-moz-calendar-picker-indicator {
            filter: invert(1) brightness(1.5) sepia(1) saturate(5) hue-rotate(45deg);
            cursor: pointer;
        }

        .date-picker span {
            color: #ccc;
            font-weight: 500;
        }

        .filter-controls .chart-btn {
            min-width: 40px;
        }

        /* 데이터 로딩 버튼 스타일 */
        .data-loading-btn {
            background: linear-gradient(135deg, #4a9eff, #007bff);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(74, 158, 255, 0.3);
        }

        .data-loading-btn:hover {
            background: linear-gradient(135deg, #007bff, #0056b3);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(74, 158, 255, 0.4);
        }

        .data-loading-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(74, 158, 255, 0.3);
        }

        .data-loading-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .date-filter-btn {
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            color: #e1e1e1;
            padding: 6px 16px;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .date-filter-btn:hover {
            background-color: #3a3a3a;
        }

        .analytics-btn {
            background: transparent;
            border: 1px solid #4a4a4a;
            color: #e1e1e1;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
            height: 32px;
        }

        .analytics-btn:hover {
            background-color: #2a2a2a;
        }

        /* 배지 스타일 */
        .role-badge {
            background-color: #3a3a3a;
            color: #e1e1e1;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            display: inline-block;
        }

        .role-badge.admin {
            background-color: #4a9eff;
            color: white;
        }

        /* Members 페이지 스타일 */
        .data-table {
            background-color: #1a1a1a;
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            overflow: hidden;
            width: 100%;
        }

        .table-header {
            background-color: #2a2a2a;
            padding: 15px 20px;
            border-bottom: 1px solid #3a3a3a;
            display: grid;
            grid-template-columns: 2fr 2fr 1fr 1fr 1fr 0.5fr;
            gap: 20px;
            font-size: 12px;
            font-weight: 600;
            color: #b1b1b1;
            text-transform: uppercase;
        }

        .table-row {
            padding: 15px 20px;
            border-bottom: 1px solid #3a3a3a;
            display: grid;
            grid-template-columns: 2fr 2fr 1fr 1fr 1fr 0.5fr;
            gap: 20px;
            align-items: center;
            font-size: 14px;
            background-color: #1a1a1a;
        }

        .table-row:hover {
            background-color: #2a2a2a;
        }

        .table-row:last-child {
            border-bottom: none;
        }

        /* Usage 페이지 스타일 */
        .usage-cards {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .usage-card {
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #3a3a3a;
        }

        .usage-card-number {
            font-size: 32px;
            font-weight: 700;
            color: #fff;
            margin-bottom: 8px;
        }

        .usage-card-label {
            color: #b1b1b1;
            font-size: 14px;
        }

        .search-box {
            background-color: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 6px;
            padding: 8px 12px;
            color: #e1e1e1;
            font-size: 14px;
            width: 250px;
        }

        .search-container {
            position: relative;
            display: inline-block;
        }

        .search-clear-btn {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #f44336;
            cursor: pointer;
            padding: 4px;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .search-clear-btn:hover {
            background-color: #f44336;
            color: white;
        }

        .search-clear-btn:active {
            background-color: #d32f2f;
            color: white;
        }

        .autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background-color: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 6px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            margin-top: 2px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .autocomplete-item {
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid #3a3a3a;
            transition: background-color 0.2s ease;
        }

        .autocomplete-item:last-child {
            border-bottom: none;
        }

        .autocomplete-item:hover {
            background-color: #3a3a3a;
        }

        .autocomplete-item.selected {
            background-color: #4a9eff;
            color: white;
        }

        .autocomplete-item .user-name {
            font-weight: 600;
            color: #e1e1e1;
            font-size: 14px;
            margin-bottom: 2px;
        }

        .autocomplete-item .user-email {
            color: #b1b1b1;
            font-size: 12px;
        }

        .autocomplete-item.selected .user-name,
        .autocomplete-item.selected .user-email {
            color: white;
        }

        .user-cumulative-info {
            background-color: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            margin-bottom: 30px;
            overflow: hidden;
        }

        .user-cumulative-header {
            background-color: #1a1a1a;
            color: #fff;
            padding: 15px 20px;
            margin: 0;
            border-bottom: 1px solid #3a3a3a;
            font-size: 18px;
            font-weight: 600;
        }

        .user-cumulative-table {
            background-color: #2a2a2a;
            padding: 15px 20px;
            border-bottom: 1px solid #3a3a3a;
            display: grid;
            grid-template-columns: 1.5fr 2fr 1fr 1.5fr 1fr 1fr 1fr;
            gap: 20px;
            font-size: 12px;
            font-weight: 600;
            color: #b1b1b1;
            text-transform: uppercase;
        }

        /* Overview 활동 테이블 스타일 */
        .overview-activity-header {
            background-color: #1a1a1a;
            color: #fff;
            padding: 15px 20px;
            margin: 0;
            border-bottom: 1px solid #3a3a3a;
            font-size: 18px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .overview-activity-table {
            background-color: #2a2a2a;
            padding: 15px 20px;
            border-bottom: 1px solid #3a3a3a;
            display: grid;
            grid-template-columns: 1.5fr 2fr 1fr 1.5fr 1fr 1fr 1fr;
            gap: 20px;
            font-size: 12px;
            font-weight: 600;
            color: #b1b1b1;
            text-transform: uppercase;
        }

        /* Export CSV 버튼 호버 효과 */
        .export-csv-btn:hover {
            background-color: #45a049 !important;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .export-csv-btn:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        .user-cumulative-row {
            padding: 15px 20px;
            border-bottom: 1px solid #3a3a3a;
            display: grid;
            grid-template-columns: 1.5fr 2fr 1fr 1.5fr 1fr 1fr 1fr;
            gap: 20px;
            align-items: center;
            font-size: 14px;
            background-color: #1a1a1a;
        }

        .user-cumulative-row:hover {
            background-color: #2a2a2a;
        }

        .user-cumulative-row:last-child {
            border-bottom: none;
        }

        .user-email {
            color: #4a9eff;
            font-weight: 600;
        }

        /* Settings 페이지 스타일 */
        .settings-section {
            background-color: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .accordion-header {
            background-color: #2a2a2a;
            padding: 20px;
            border-bottom: 1px solid #3a3a3a;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
        }

        .accordion-header:hover {
            background-color: #3a3a3a;
        }

        .accordion-title {
            font-size: 18px;
            font-weight: 600;
            color: #fff;
        }

        .accordion-arrow {
            font-size: 16px;
            color: #b1b1b1;
            transition: transform 0.2s ease;
        }

        .accordion-content {
            display: none;
            padding: 20px;
            background-color: #1a1a1a;
        }

        .accordion-content.active {
            display: block;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #3a3a3a;
        }

        .setting-item:last-child {
            border-bottom: none;
        }

        .setting-label {
            color: #fff;
            margin-bottom: 4px;
        }

        .setting-description {
            color: #7a7a7a;
            font-size: 12px;
        }

        .toggle-switch {
            width: 44px;
            height: 24px;
            background-color: #4a9eff;
            border-radius: 12px;
            position: relative;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .toggle-switch.off {
            background-color: #5a5a5a;
        }

        .toggle-switch::after {
            content: '';
            width: 20px;
            height: 20px;
            background-color: white;
            border-radius: 50%;
            position: absolute;
            top: 2px;
            right: 2px;
            transition: all 0.2s ease;
        }

        .toggle-switch.off::after {
            right: 22px;
        }

        .setting-select {
            background: #3a3a3a;
            color: #fff;
            border: 1px solid #4a4a4a;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
        }

        .export-btn {
            background: #4a9eff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s;
        }

        .export-btn:hover {
            background: #3a8edf;
        }

        /* 반응형 */
        @media (max-width: 768px) {
            .sidebar {
                width: 70px;
            }
           
            .menu-text {
                display: none;
            }

            .overview-stats {
                grid-template-columns: 1fr;
            }

            .member-item,
            .member-list-header,
            .table-row,
            .table-header,
            .user-cumulative-row,
            .user-cumulative-table {
                grid-template-columns: 1fr;
                gap: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="dashboard-container">
        <!-- 사이드바 -->
        <nav class="sidebar">
            <div style="height: 20px;"></div>
            <a href="javascript:void(0)" class="refresh-button" onclick="handleRefreshClick()">
                <span class="menu-icon">🔄</span>
                <span class="menu-text">사용자 정보 업데이트</span>
                <div class="refresh-progress">
                    <div class="refresh-progress-bar"></div>
                </div>
            </a>
            <div style="height: 1px; background-color: #3a3a3a; margin: 10px 20px;"></div>
            <a href="javascript:void(0)" class="menu-item active" data-section="overview">
                <span class="menu-icon">📊</span>
                <span class="menu-text">Overview</span>
            </a>
            <a href="javascript:void(0)" class="menu-item" data-section="settings">
                <span class="menu-icon">⚙️</span>
                <span class="menu-text">Settings</span>
            </a>
            <a href="javascript:void(0)" class="menu-item" data-section="members">
                <span class="menu-icon">👥</span>
                <span class="menu-text">Members</span>
            </a>
            <a href="javascript:void(0)" class="menu-item" data-section="usage">
                <span class="menu-icon">📈</span>
                <span class="menu-text">Usage</span>
            </a>
        </nav>

        <!-- 메인 콘텐츠 -->
        <main class="main-content">
            <header class="header">
                <div class="header-left">
                    <h1 id="page-title">Dashboard Overview</h1>
                </div>
                <div class="header-right">
                    <!-- Clear Cache button and Ready status removed -->
                </div>
            </header>

            <div class="content-area">
                <!-- Overview 섹션 -->
                <div id="overview" class="content-section active">
                    <!-- 2.1.1 필터링 기능 -->
                    <div class="filter-controls">
                        <div class="chart-controls">
                            <button class="chart-btn" data-days="1">1d</button>
                            <button class="chart-btn" data-days="7">7d</button>
                            <button class="chart-btn active" data-days="30">30d</button>
                            <div class="date-picker">
                                <input type="date" id="start-date" />
                                <span>~</span>
                                <input type="date" id="end-date" />
                                <button class="analytics-btn" onclick="applyDateFilter()">적용</button>
                            </div>
                        </div>

                    </div>

                    <!-- 사용량 개요 카드 (Usage에서 이동) -->
                    <div class="usage-cards">
                        <div class="usage-card">
                            <div class="usage-card-number">-</div>
                            <div class="usage-card-label">Total Users</div>
                        </div>
                        <div class="usage-card">
                            <div class="usage-card-number">-</div>
                            <div class="usage-card-label">Lines of Agent Edits</div>
                        </div>
                        <div class="usage-card">
                            <div class="usage-card-number">-</div>
                            <div class="usage-card-label">Tabs Accepted</div>
                        </div>
                        <div class="usage-card">
                            <div class="usage-card-number">-</div>
                            <div class="usage-card-label">Chats</div>
                        </div>
                    </div>

                    <!-- 그래프 영역 -->
                    <div class="overview-chart-container">
                        <div class="chart-header">
                            <h3>일별 활동 추이</h3>
                        </div>
                        <canvas id="overviewChart" style="width: 100%; height: 300px;"></canvas>
                    </div>

                    <!-- 2.1.2 통계 카드 -->
                    <div class="overview-stats">
                        <div class="overview-stat-box clickable" data-type="total" onclick="filterOverviewMembersByType('total')">
                            <div class="stat-number">20</div>
                            <div class="stat-label">
                                <span class="role-badge" style="background-color: #4a9eff; color: white;">전체 멤버</span>
                            </div>
                            <div class="stat-description">모든 멤버의 활동 기록</div>
                        </div>
                        <div class="overview-stat-box clickable" data-type="active" onclick="filterOverviewMembersByType('active')">
                            <div class="stat-number">13</div>
                            <div class="stat-label">
                                <span class="role-badge" style="background-color: #4caf50; color: white;">활성 멤버</span>
                            </div>
                            <div class="stat-description">활성 멤버의 활동 기록</div>
                        </div>
                        <div class="overview-stat-box clickable" data-type="inactive" onclick="filterOverviewMembersByType('inactive')">
                            <div class="stat-number">7</div>
                            <div class="stat-label">
                                <span class="role-badge" style="background-color: #ff9800; color: white;">비활성 멤버</span>
                            </div>
                            <div class="stat-description">비활성 멤버의 활동 기록</div>
                        </div>
                    </div>

                    <!-- 멤버 세부 리스트 -->
                    <div class="overview-member-details">
                        <div class="overview-activity-header">📋 활동 리스트</div>
                        <div class="overview-activity-table">
                            <div>마지막 활동</div>
                            <div>사용자</div>
                            <div>상태</div>
                            <div>활동 유형</div>
                            <div>요청 수</div>
                            <div>비용</div>
                            <div>제한</div>
                        </div>
                        <div id="overview-activity-container">
                            <!-- 동적으로 생성될 테이블 내용 -->
                            <div style="padding: 20px; text-align: center; color: #7a7a7a; background-color: #1a1a1a;">
                                데이터를 불러오는 중...
                            </div>
                        </div>
                        
                        <!-- Overview 활동리스트 페이지네이션 (Members 스타일) -->
                        <div id="overview-activity-pagination" style="display: none; padding: 15px 20px; background-color: #2a2a2a; border-top: 1px solid #3a3a3a; text-align: center;">
                            <!-- 숫자 페이지 버튼들이 동적으로 생성됨 -->
                        </div>
                    </div>
                </div>

                <!-- Members 섹션 -->
                <div id="members" class="content-section">
                    <div class="filter-controls" style="margin-bottom: 10px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                            <div style="color: #e1e1e1; font-size: 14px; font-weight: 500; margin-left: 20px;">
                                Fast Requests last reset on: <span id="fast-requests-reset-date" style="color: #ffffff; font-weight: 600;">2025년 7월 22일</span> (오늘 날짜: <span id="today-date" style="color: #ff9800; font-weight: 600;">2025-08-03</span>)
                            </div>
                            <div style="display: flex; align-items: center; gap: 15px; margin-left: auto;">
                                <div class="search-container">
                                    <div style="position: relative; display: flex; align-items: center;">
                                        <span style="position: absolute; left: 12px; color: #7a7a7a; font-size: 14px;">🔍</span>
                                        <input type="text" class="search-box" id="members-search" placeholder="Search name, email..." onkeyup="filterMembers(this.value)" oninput="toggleSearchClearBtn('members-search'); showAutocomplete('members-search')" autocomplete="off" style="padding-left: 35px;">
                                        <button class="search-clear-btn" id="members-search-clear" onclick="clearSearch('members-search')" style="display: none;">×</button>
                                    </div>
                                    <div id="members-autocomplete" class="autocomplete-dropdown" style="display: none;"></div>
                                </div>
                                <button class="export-csv-btn" onclick="exportMembersToCSV()" style="background: #4caf50; color: white; border: none; padding: 8px 16px; border-radius: 4px; font-size: 14px; font-weight: 500; cursor: pointer; transition: background-color 0.2s ease;">
                                    📊 Export CSV
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="data-table" id="members-table-container">
                        <!-- 동적으로 생성될 테이블 헤더와 내용 -->
                        <div style="padding: 20px; text-align: center; color: #7a7a7a; background-color: #1a1a1a;">
                            실제 멤버 데이터를 로딩하는 중...
                        </div>
                    </div>
                    
                    <!-- Members 페이지네이션 (All Raw Events 스타일) -->
                    <div id="members-pagination" style="display: none; padding: 15px 20px; background-color: #2a2a2a; border-top: 1px solid #3a3a3a; text-align: center;">
                        <!-- 숫자 페이지 버튼들이 동적으로 생성됨 -->
                    </div>
                </div>

                <!-- Usage 섹션 -->
                <div id="usage" class="content-section">
                    <!-- 날짜 필터와 검색 -->
                    <div class="filter-controls">
                        <div class="chart-controls">
                            <button class="chart-btn" data-days="1">1d</button>
                            <button class="chart-btn" data-days="7">7d</button>
                            <button class="chart-btn active" data-days="30">30d</button>
                            <div class="date-picker">
                                <input type="date" id="usage-start-date" />
                                <span>~</span>
                                <input type="date" id="usage-end-date" />
                                <button class="analytics-btn" onclick="applyUsageDateFilter()">적용</button>
                            </div>
                        </div>
                        <div>
                            <div class="search-container">
                                <div style="position: relative; display: flex; align-items: center;">
                                    <span style="position: absolute; left: 12px; color: #7a7a7a; font-size: 14px;">🔍</span>
                                    <input type="text" class="search-box" id="usage-search" placeholder="Search name, email..." onkeyup="filterUsageMembers(this.value)" oninput="toggleSearchClearBtn('usage-search'); showAutocomplete('usage-search')" autocomplete="off" style="padding-left: 35px;">
                                    <button class="search-clear-btn" id="usage-search-clear" onclick="clearSearch('usage-search')" style="display: none;">×</button>
                                </div>
                                <div id="usage-autocomplete" class="autocomplete-dropdown" style="display: none;"></div>
                            </div>
                        </div>
                    </div>

                    <!-- 사용자별 누적 정보 -->
                    <div class="user-cumulative-info">
                        <div class="user-cumulative-header">📊 사용자별 누적 사용량 정보</div>
                        <div class="user-cumulative-table">
                            <div>NAME</div>
                            <div>EMAIL</div>
                            <div>ROLE</div>
                            <div>REQUEST</div>
                            <div>SPEND</div>
                            <div>LAST ACT</div>
                        </div>
                        <div id="user-cumulative-container">
                            <!-- 동적으로 생성될 테이블 내용 -->
                            <div style="padding: 20px; text-align: center; color: #7a7a7a; background-color: #1a1a1a;">
                                데이터를 불러오는 중...
                            </div>
                        </div>
                        
                        <!-- 사용자별 누적 사용량 정보 페이지네이션 (All Raw Events 스타일) -->
                        <div id="user-cumulative-pagination" style="display: none; padding: 15px 20px; background-color: #2a2a2a; border-top: 1px solid #3a3a3a; text-align: center;">
                            <!-- 숫자 페이지 버튼들이 동적으로 생성됨 -->
                        </div>
                    </div>

                    <!-- All Raw Events 테이블 -->
                    <div class="user-cumulative-info">
                        <div class="user-cumulative-header">📋 All Raw Events</div>
                        <div class="user-cumulative-table">
                            <div>DATE</div>
                            <div>USER</div>
                            <div>KIND</div>
                            <div>MAX_MODEL</div>
                            <div>MODEL</div>
                            <div>TOKENS</div>
                            <div>COST</div>
                        </div>
                        <div style="padding: 20px; text-align: center; color: #7a7a7a; background-color: #1a1a1a;">
                            데이터를 불러오는 중...
                        </div>
                        
                        <!-- 필터링된 이벤트 페이지네이션 -->
                        <div class="filtered-events-pagination" style="display: none; padding: 15px 20px; background-color: #2a2a2a; border-top: 1px solid #3a3a3a; text-align: center;">
                            <!-- 숫자 페이지 버튼들이 동적으로 생성됨 -->
                        </div>
                    </div>
                </div>

                <!-- Settings 섹션 -->
                <div id="settings" class="content-section">
                    <!-- 활성 기간 설정 -->
                    <div class="settings-section">
                        <div class="accordion-header" onclick="toggleAccordion(this)">
                            <div class="accordion-title">활성 기간 설정</div>
                            <div class="accordion-arrow">▼</div>
                        </div>
                        <div class="accordion-content">
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label">활성 상태 자동 전환</div>
                                    <div class="setting-description">지정된 기간 동안 활동이 없으면 자동으로 비활성 상태로 전환됩니다</div>
                                </div>
                                <div class="toggle-switch" onclick="toggleSwitch(this)"></div>
                            </div>
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label">비활성 전환 기간</div>
                                    <div class="setting-description">활동이 없을 경우 비활성으로 전환되는 기간</div>
                                </div>
                                <select class="setting-select">
                                    <option>7일</option>
                                    <option>14일</option>
                                    <option selected>30일</option>
                                    <option>60일</option>
                                    <option>90일</option>
                                </select>
                            </div>
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label">활성 상태 알림</div>
                                    <div class="setting-description">비활성 전환 전 사용자에게 알림을 발송합니다</div>
                                </div>
                                <div class="toggle-switch" onclick="toggleSwitch(this)"></div>
                            </div>
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label">알림 발송 시점</div>
                                    <div class="setting-description">비활성 전환 몇 일 전에 알림을 발송할지 설정</div>
                                </div>
                                <select class="setting-select">
                                    <option>1일 전</option>
                                    <option selected>3일 전</option>
                                    <option>7일 전</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Email Report 설정 -->
                    <div class="settings-section">
                        <div class="accordion-header" onclick="toggleAccordion(this)">
                            <div class="accordion-title">Email Report 설정</div>
                            <div class="accordion-arrow">▼</div>
                        </div>
                        <div class="accordion-content">
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label">자동 리포트 발송</div>
                                    <div class="setting-description">정기적으로 사용 현황 리포트를 이메일로 발송합니다</div>
                                </div>
                                <div class="toggle-switch" onclick="toggleSwitch(this)"></div>
                            </div>
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label">발송 주기</div>
                                    <div class="setting-description">리포트 발송 주기를 설정합니다</div>
                                </div>
                                <select class="setting-select">
                                    <option>매일</option>
                                    <option selected>매주</option>
                                    <option>매월</option>
                                    <option>분기별</option>
                                </select>
                            </div>
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label">수신자 그룹</div>
                                    <div class="setting-description">리포트를 받을 대상을 설정합니다</div>
                                </div>
                                <div style="display: flex; gap: 10px;">
                                    <label style="display: flex; align-items: center; gap: 5px;">
                                        <input type="checkbox" checked style="width: 16px; height: 16px;">
                                        <span style="color: #e1e1e1; font-size: 14px;">관리자</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 5px;">
                                        <input type="checkbox" style="width: 16px; height: 16px;">
                                        <span style="color: #e1e1e1; font-size: 14px;">전체 멤버</span>
                                    </label>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Export Documents 설정 -->
                    <div class="settings-section">
                        <div class="accordion-header" onclick="toggleAccordion(this)">
                            <div class="accordion-title">Export Documents 설정</div>
                            <div class="accordion-arrow">▼</div>
                        </div>
                        <div class="accordion-content">
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label">자동 백업</div>
                                    <div class="setting-description">데이터를 정기적으로 자동 백업합니다</div>
                                </div>
                                <div class="toggle-switch" onclick="toggleSwitch(this)"></div>
                            </div>
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label">Export 형식</div>
                                    <div class="setting-description">문서를 내보낼 파일 형식을 선택합니다</div>
                                </div>
                                <select class="setting-select">
                                    <option>CSV</option>
                                    <option selected>Excel (XLSX)</option>
                                    <option>PDF</option>
                                    <option>JSON</option>
                                </select>
                            </div>
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label">Export 범위</div>
                                    <div class="setting-description">내보낼 데이터의 기간을 설정합니다</div>
                                </div>
                                <select class="setting-select">
                                    <option>최근 7일</option>
                                    <option selected>최근 30일</option>
                                    <option>최근 90일</option>
                                    <option>전체 기간</option>
                                    <option>사용자 지정</option>
                                </select>
                            </div>
                            <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #3a3a3a;">
                                <button class="export-btn">📥 지금 Export 하기</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // 멤버 활동 데이터
        const memberData = {
            total: [
                { date: "25년 7월 25일 (오늘)", email: "greenmold@samsung.com", type: "active", kind: "Chat Request", request: "3", spend: "$0.05" },
                { date: "25년 7월 25일 (오늘)", email: "ck9104.lee@samsung.com", type: "active", kind: "Code Generation", request: "2", spend: "$0.03" },
                { date: "25년 7월 25일 (오늘)", email: "by07.so@samsung.com", type: "active", kind: "Analysis", request: "5", spend: "$0.08" },
                { date: "25년 7월 24일 (1일전)", email: "dynamic.choi@samsung.com", type: "inactive", kind: "Chat Request", request: "1", spend: "$0.01" },
                { date: "25년 7월 24일 (1일전)", email: "darney.jeon@samsung.com", type: "inactive", kind: "Code Review", request: "2", spend: "$0.02" },
                { date: "25년 7월 24일 (1일전)", email: "j0117.lee@samsung.com", type: "active", kind: "Documentation", request: "4", spend: "$0.04" },
                { date: "25년 7월 24일 (1일전)", email: "kaeul.kim@samsung.com", type: "active", kind: "Chat Request", request: "6", spend: "$0.06" },
                { date: "25년 7월 24일 (1일전)", email: "nw.aioffice@samsung.com", type: "inactive", kind: "Analysis", request: "1", spend: "$0.01" },
                { date: "25년 7월 24일 (1일전)", email: "sh.ryan.park@samsung.com", type: "active", kind: "Code Generation", request: "7", spend: "$0.07" },
                { date: "25년 7월 24일 (1일전)", email: "sejin.seo@samsung.com", type: "active", kind: "Chat Request", request: "3", spend: "$0.03" },
                { date: "25년 7월 23일 (2일전)", email: "sol22.lee@samsung.com", type: "inactive", kind: "Documentation", request: "2", spend: "$0.02" },
                { date: "25년 7월 23일 (2일전)", email: "shee.lim@samsung.com", type: "inactive", kind: "Analysis", request: "1", spend: "$0.01" },
                { date: "25년 7월 23일 (2일전)", email: "joseph2.jeon@samsung.com", type: "active", kind: "Code Review", request: "5", spend: "$0.05" },
                { date: "25년 7월 23일 (2일전)", email: "taewoo.bang@samsung.com", type: "inactive", kind: "Chat Request", request: "1", spend: "$0.01" },
                { date: "25년 7월 23일 (2일전)", email: "baewj@samsung.com", type: "inactive", kind: "Code Generation", request: "3", spend: "$0.03" },
                { date: "25년 7월 22일 (3일전)", email: "yj7.park@samsung.com", type: "active", kind: "Analysis", request: "4", spend: "$0.04" },
                { date: "25년 7월 22일 (3일전)", email: "nemo.kim@samsung.com", type: "active", kind: "Chat Request", request: "6", spend: "$0.06" },
                { date: "25년 7월 22일 (3일전)", email: "ms0402.kim@samsung.com", type: "active", kind: "Documentation", request: "3", spend: "$0.03" },
                { date: "25년 7월 21일 (4일전)", email: "shx.kim@samsung.com", type: "active", kind: "Code Review", request: "5", spend: "$0.05" },
                { date: "25년 7월 21일 (4일전)", email: "greenmold@samsung.com", type: "active", kind: "Analysis", request: "8", spend: "$0.08" }
            ]
        };

        // 활성/비활성 멤버 활동 분류
        memberData.active = memberData.total.filter(activity => activity.type === "active");
        memberData.inactive = memberData.total.filter(activity => activity.type === "inactive");

        // 멤버 리스트 렌더링
        function renderMemberList(type) {
            const memberList = document.getElementById('member-list');
            const memberListTitle = document.getElementById('member-list-title');
           
            let activities = [];
            let title = "";
            let icon = "";
           
            switch(type) {
                case 'active':
                    activities = memberData.active;
                    title = "활성 멤버 활동 리스트";
                    icon = "🟢";
                    break;
                case 'inactive':
                    activities = memberData.inactive;
                    title = "비활성 멤버 활동 리스트";
                    icon = "🟠";
                    break;
                default:
                    activities = memberData.total;
                    title = "전체 활동 리스트";
                    icon = "📊";
            }
           
            memberListTitle.textContent = `${icon} ${title}`;
           
            memberList.innerHTML = `
                <div class="member-list-header">
                    <div>DATE</div>
                    <div>EMAIL</div>
                    <div>TYPE</div>
                    <div>KIND</div>
                    <div>REQUEST</div>
                    <div>SPEND</div>
                </div>
                ${activities.map(activity => `
                    <div class="member-item">
                        <div class="member-date">${activity.date}</div>
                        <div class="member-email">${activity.email}</div>
                        <div class="member-type ${activity.type}">${activity.type === 'active' ? '활성' : '비활성'}</div>
                        <div class="member-kind">${activity.kind}</div>
                        <div class="member-request">${activity.request}</div>
                        <div class="member-spend">${activity.spend}</div>
                    </div>
                `).join('')}
            `;
        }

        // 통계 박스 클릭 이벤트
        function initOverviewStats() {
            const statBoxes = document.querySelectorAll('.overview-stat-box');
           
            statBoxes.forEach(box => {
                box.addEventListener('click', function() {
                    // 모든 박스에서 selected 클래스 제거
                    statBoxes.forEach(b => b.classList.remove('selected'));
                   
                    // 클릭된 박스에 selected 클래스 추가
                    this.classList.add('selected');
                   
                    // 해당 타입의 멤버 리스트 표시
                    const type = this.getAttribute('data-type');
                    renderMemberList(type);
                });
            });
           
            // 초기 로드 시 전체 멤버 리스트 표시
            renderMemberList('total');
        }

        // 차트 생성 (Overview용)
        function createOverviewChart() {
            const canvas = document.getElementById('overviewChart');
            if (!canvas) return;
           
            // Canvas 크기 설정
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = 300;
           
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
           
            // 배경 설정
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);
           
            // 그리드 그리기
            ctx.strokeStyle = '#3a3a3a';
            ctx.lineWidth = 1;
           
            // 세로 그리드
            for (let i = 0; i <= 6; i++) {
                const x = (width / 6) * i;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
           
            // 가로 그리드
            for (let i = 0; i <= 5; i++) {
                const y = (height / 5) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
           
            // 데이터 포인트 (예시)
            const dataPoints = [
                {x: width * 0.1, y: height * 0.8},
                {x: width * 0.25, y: height * 0.7},
                {x: width * 0.4, y: height * 0.6},
                {x: width * 0.55, y: height * 0.3},
                {x: width * 0.7, y: height * 0.4},
                {x: width * 0.85, y: height * 0.5}
            ];
           
            // 선 그래프 그리기
            ctx.strokeStyle = '#4a9eff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(dataPoints[0].x, dataPoints[0].y);
           
            for (let i = 1; i < dataPoints.length; i++) {
                ctx.lineTo(dataPoints[i].x, dataPoints[i].y);
            }
            ctx.stroke();
           
            // 데이터 포인트 원 그리기
            dataPoints.forEach(point => {
                ctx.fillStyle = '#4a9eff';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 4, 0, Math.PI * 2);
                ctx.fill();
            });
           
            // 날짜 레이블
            const dates = ['Jul 18', 'Jul 19', 'Jul 20', 'Jul 21', 'Jul 22', 'Jul 23', 'Jul 24'];
            ctx.fillStyle = '#7a7a7a';
            ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.textAlign = 'center';
           
            dates.forEach((date, index) => {
                const x = (width / 6) * index;
                ctx.fillText(date, x, height - 10);
            });
        }

        // 메뉴 클릭 이벤트 처리
        document.querySelectorAll('.menu-item').forEach(item => {
            item.addEventListener('click', function(e) {
                e.preventDefault();
               
                // 모든 메뉴 아이템에서 active 클래스 제거
                document.querySelectorAll('.menu-item').forEach(menu => {
                    menu.classList.remove('active');
                });
               
                // 클릭된 메뉴에 active 클래스 추가
                this.classList.add('active');
               
                // 모든 콘텐츠 섹션 숨기기
                document.querySelectorAll('.content-section').forEach(section => {
                    section.classList.remove('active');
                });
               
                // 선택된 섹션 표시
                const sectionName = this.getAttribute('data-section');
                const targetSection = document.getElementById(sectionName);
                if (targetSection) {
                    targetSection.classList.add('active');
                }
               
                // 헤더 제목 업데이트
                const pageTitle = document.getElementById('page-title');
               
                switch(sectionName) {
                    case 'overview':
                        pageTitle.textContent = 'Dashboard Overview';
                        // 필터 기본값 설정 후
                        setTimeout(async () => {
                            createOverviewChart();
                            console.log('=== Overview 메뉴 클릭 시 자동 실제 API 데이터 새로고침 시작 ===');
                            await refreshAllRealData(); // 자동 새로고침
                        }, 100);
                        break;
                    case 'members':
                        pageTitle.textContent = 'Dashboard Members';
                        // Members 메뉴 클릭 시 자동 새로고침
                        setTimeout(async () => {
                            console.log('=== Members 메뉴 클릭 시 자동 실제 API 데이터 새로고침 시작 ===');
                            await updateMembersWithRealData();
                        }, 100);
                        break;
                    case 'usage':
                        pageTitle.textContent = 'Usage Analytics';
                        // Usage 메뉴 클릭 시 조건부 데이터 로딩
                        setTimeout(async () => {
                            if (!isUsageDataLoaded) {
                                console.log('=== Usage 메뉴 첫 번째 클릭 - 데이터 로딩 시작 ===');
                                await updateUsageWithCurrentFilter(30, true); // 첫 번째 로딩
                            } else {
                                console.log('=== Usage 메뉴 재클릭 - 백그라운드 데이터 갱신 ===');
                                updateUsageWithCurrentFilter(30, false); // 백그라운드 로딩
                            }
                        }, 100);
                        break;
                    case 'settings':
                        pageTitle.textContent = 'Settings';
                        break;
                    default:
                        pageTitle.textContent = sectionName.charAt(0).toUpperCase() + sectionName.slice(1);
                }
            });
        });

        // 아코디언 토글 함수
        function toggleAccordion(header) {
            const content = header.nextElementSibling;
            const arrow = header.querySelector('.accordion-arrow');
           
            // 다른 모든 아코디언 닫기
            document.querySelectorAll('.accordion-content').forEach(otherContent => {
                if (otherContent !== content) {
                    otherContent.classList.remove('active');
                    otherContent.previousElementSibling.querySelector('.accordion-arrow').textContent = '▼';
                }
            });
           
            // 현재 아코디언 토글
            if (content.classList.contains('active')) {
                content.classList.remove('active');
                arrow.textContent = '▼';
            } else {
                content.classList.add('active');
                arrow.textContent = '▲';
            }
        }

        // 토글 스위치 함수
        function toggleSwitch(toggle) {
            toggle.classList.toggle('off');
        }

        // Overview 통계 카드 클릭 시 멤버 타입별 필터링
        function filterOverviewMembersByType(type) {
            console.log(`=== Overview 통계 카드 클릭: ${type} ===`);
            
            // 선택 상태 업데이트
            updateOverviewSelection(type);
            currentFilterType = type;
            
            // 멤버 데이터 필터링 및 표시
            filterAndDisplayMembers(type);
            
            console.log(`통계 카드 선택 완료: ${type} - 필터링된 데이터 표시`);
        }

        // 멤버 데이터를 타입별로 필터링하고 표시
        function filterAndDisplayMembers(type) {
            console.log(`=== 멤버 데이터 필터링 시작: ${type} ===`);
            
            if (!originalMembersData || originalMembersData.length === 0) {
                console.log('필터링할 멤버 데이터가 없습니다.');
                return;
            }
            
            let filteredMembers = [];
            
            if (type === 'total') {
                // 전체 멤버 표시
                filteredMembers = [...originalMembersData];
                console.log(`전체 멤버 표시: ${filteredMembers.length}명`);
            } else if (type === 'active') {
                // 활성 멤버만 필터링 (Premium Requests가 있는 멤버)
                filteredMembers = originalMembersData.filter(member => 
                    member.spendData.premiumRequests > 0
                );
                console.log(`활성 멤버 필터링: ${filteredMembers.length}명`);
            } else if (type === 'inactive') {
                // 비활성 멤버만 필터링 (Premium Requests가 없는 멤버)
                filteredMembers = originalMembersData.filter(member => 
                    member.spendData.premiumRequests === 0
                );
                console.log(`비활성 멤버 필터링: ${filteredMembers.length}명`);
            }
            
            // 필터링된 데이터로 테이블 업데이트
            if (filteredMembers.length > 0) {
                currentMembersData = filteredMembers;
                currentMembersPage = 1; // 페이지 리셋
                renderMembersTableWithPagination(filteredMembers);
            } else {
                // 데이터가 없을 경우 빈 테이블 표시
                const container = document.getElementById('members-table-container');
                if (container) {
                    container.innerHTML = `
                        <div style="padding: 20px; text-align: center; color: #7a7a7a; background-color: #1a1a1a;">
                            ${type === 'active' ? '활성 멤버가 없습니다.' : 
                              type === 'inactive' ? '비활성 멤버가 없습니다.' : 
                              '멤버 데이터가 없습니다.'}
                        </div>
                    `;
                }
            }
            
            // 활동 리스트도 함께 업데이트
            updateActivityListByType(type);
            
            console.log(`=== 멤버 데이터 필터링 완료: ${type} ===`);
        }

        // 활동 리스트를 타입별로 필터링하고 업데이트
        function updateActivityListByType(type) {
            console.log(`=== 활동 리스트 필터링 시작: ${type} ===`);
            
            if (!currentActivities || currentActivities.length === 0) {
                console.log('필터링할 활동 데이터가 없습니다.');
                updateActivityList([]);
                return;
            }
            
            let filteredActivities = [];
            
            if (type === 'total') {
                // 전체 활동 표시
                filteredActivities = [...currentActivities];
                console.log(`전체 활동 표시: ${filteredActivities.length}개`);
            } else if (type === 'active') {
                // 활성 활동만 필터링
                filteredActivities = currentActivities.filter(activity => 
                    activity.type === 'active'
                );
                console.log(`활성 활동 필터링: ${filteredActivities.length}개`);
            } else if (type === 'inactive') {
                // 비활성 활동만 필터링
                filteredActivities = currentActivities.filter(activity => 
                    activity.type === 'inactive'
                );
                console.log(`비활성 활동 필터링: ${filteredActivities.length}개`);
            }
            
            // 필터링된 활동 데이터로 리스트 업데이트
            updateActivityList(filteredActivities);
            
            console.log(`=== 활동 리스트 필터링 완료: ${type} ===`);
        }

        // Overview 통계 카드 선택 상태 업데이트
        function updateOverviewSelection(type) {
            // 모든 통계 카드에서 selected 클래스 제거
            document.querySelectorAll('.overview-stat-box').forEach(box => {
                box.classList.remove('selected');
            });
            
            // 클릭된 카드에 selected 클래스 추가
            const targetBox = document.querySelector(`.overview-stat-box[data-type="${type}"]`);
            if (targetBox) {
                targetBox.classList.add('selected');
            }
            
            console.log(`통계 카드 선택 상태 업데이트: ${type}`);
        }

        // 타입별 멤버 데이터를 실제 API에서 가져와서 표시
        async function updateMembersByTypeWithRealData(type) {
            console.log(`=== ${type} 멤버 실제 API 데이터 로드 시작 ===`);
            console.log(`요청된 타입: ${type}, 현재 필터 타입: ${currentFilterType}`);
           
            // 현재 필터 기간 결정
            let dateRange;
            if (currentDateRange) {
                dateRange = currentDateRange;
            } else {
                const filterDays = getCurrentFilterDays();
                dateRange = getDateRange(filterDays);
            }
           
            console.log(`필터 기간: ${new Date(dateRange.startDate).toLocaleDateString()} ~ ${new Date(dateRange.endDate).toLocaleDateString()}`);
           
            // 실제 API 데이터 가져오기
            const [membersData, eventsData] = await Promise.all([
                getTeamMembers(),
                getFilteredEvents(dateRange.startDate, dateRange.endDate)
            ]);
           
            if (!membersData || !membersData.teamMembers) {
                throw new Error('멤버 데이터를 가져올 수 없습니다.');
            }
           
            console.log(`API 응답: 멤버 ${membersData.teamMembers.length}명, 이벤트 ${eventsData?.usageEvents?.length || 0}개`);
           
            if (type === 'inactive') {
                // 비활성 멤버 처리
                await showInactiveMembersWithData(membersData, eventsData);
            } else if (type === 'active') {
                // 활성 멤버 처리
                await showActiveMembersWithData(membersData, eventsData, 'active');
            } else if (type === 'total') {
                // 전체 멤버 처리
                await showActiveMembersWithData(membersData, eventsData, 'total');
            } else {
                console.error(`알 수 없는 타입: ${type}`);
                currentActivityPage = 1; // 페이지네이션 초기화
                updateActivityList([]);
                // 제목은 동적으로 생성됨
            }
           
            console.log(`=== ${type} 멤버 실제 API 데이터 로드 완료 ===`);
        }

        // 활성 멤버 또는 전체 멤버 표시
        async function showActiveMembersWithData(membersData, eventsData, type) {
            console.log(`=== ${type} 멤버 데이터 표시 시작 ===`);
           
            if (!eventsData || !eventsData.usageEvents) {
                console.log('활동 이벤트 데이터가 없습니다.');
                currentActivityPage = 1; // 페이지네이션 초기화
                updateActivityList([]);
                // 제목은 동적으로 생성됨
                return;
            }
           
            // 지출 데이터 가져오기
            const spendingData = await getTeamSpendingData();
            const memberSpendMap = {};
            if (spendingData && spendingData.teamMemberSpend) {
                spendingData.teamMemberSpend.forEach(spendInfo => {
                    memberSpendMap[spendInfo.email] = {
                        premiumRequests: spendInfo.fastPremiumRequests || 0,
                        spend: (spendInfo.spendCents || 0) / 100,
                        hardLimitOverride: spendInfo.hardLimitOverrideDollars || 0
                    };
                });
            }
           
            // 실제 활동 리스트 생성
            const activities = createActivityListWithLastActivity(eventsData.usageEvents, membersData.teamMembers, memberSpendMap);
            console.log(`생성된 활동 리스트: ${activities.length}명`);
           
            let filteredActivities;
            if (type === 'active') {
                // 활성 멤버: request > 0인 멤버만
                filteredActivities = activities.filter(activity => activity.request > 0);
            } else if (type === 'total') {
                // 전체 멤버: 실제 활동이 있는 모든 멤버
                filteredActivities = activities;
            } else {
                // 기본값: 전체 멤버
                filteredActivities = activities;
                console.log(`기본 전체 멤버 표시: ${filteredActivities.length}명`);
            }
           
            console.log(`${type} 멤버 최종 데이터: ${filteredActivities.length}명`);
            console.log('표시될 멤버 목록:', filteredActivities.map(a => `${a.email} (${a.request} requests)`));
           
            updateActivityList(filteredActivities);
            // 제목은 동적으로 생성됨
           
            console.log(`=== ${type} 멤버 데이터 표시 완료 ===`);
        }

        // 비활성 멤버 표시 함수 (데이터와 함께)
        async function showInactiveMembersWithData(membersData, eventsData) {
            console.log('=== 비활성 멤버 표시 시작 ===');
           
            // 지출 데이터 가져오기
            const spendingData = await getTeamSpendingData();
            const memberSpendMap = {};
            if (spendingData && spendingData.teamMemberSpend) {
                spendingData.teamMemberSpend.forEach(spendInfo => {
                    memberSpendMap[spendInfo.email] = {
                        premiumRequests: spendInfo.fastPremiumRequests || 0,
                        spend: (spendInfo.spendCents || 0) / 100,
                        hardLimitOverride: spendInfo.hardLimitOverrideDollars || 0
                    };
                });
            }
           
            // 활동이 있는 사용자 목록 생성
            const activeUserEmails = new Set();
            if (eventsData && eventsData.usageEvents) {
                eventsData.usageEvents.forEach(event => {
                    if (event.userEmail && event.requestsCosts > 0) {
                        activeUserEmails.add(event.userEmail);
                    }
                });
            }
           
            // 비활성 멤버 필터링
            const inactiveMembers = membersData.teamMembers.filter(member =>
                !activeUserEmails.has(member.email)
            );
           
            console.log(`비활성 멤버: ${inactiveMembers.length}명`);
            console.log('비활성 멤버 목록:', inactiveMembers.map(m => m.email));
           
            // 비활성 멤버를 활동 리스트 형태로 변환
            const inactiveActivities = inactiveMembers.map(member => {
                const spendData = memberSpendMap[member.email] || {};
                const actualSpend = spendData.spend || 0; // 실제 지출 데이터 사용
                const premiumRequests = spendData.premiumRequests || 0;
                const hardLimit = spendData.hardLimitOverride || 0;
                const limitDisplay = hardLimit > 0 ? `$${hardLimit}` : '$0';
               
                return {
                    date: 'No Activity',
                    timestamp: 0,
                    email: member.email,
                    name: member.name || 'Unnamed',
                    type: 'inactive',
                    kind: 'No Activity',
                    request: premiumRequests, // Premium Requests 사용
                    spend: `$${actualSpend.toFixed(2)}`, // 실제 지출 데이터 사용
                    limit: limitDisplay
                };
            });
           
            currentActivityPage = 1; // 페이지네이션 초기화
            updateActivityList(inactiveActivities);
            // 제목은 동적으로 생성됨
        }

        // 비활성 멤버 표시 함수 (기존 호환성 유지)
        async function showInactiveMembers() {
            try {
                console.log('=== 비활성 멤버 표시 시작 (기존 함수) ===');
               
                // 현재 필터 기간의 이벤트 데이터 가져오기
                let dateRange;
                if (currentDateRange) {
                    dateRange = currentDateRange;
                } else {
                    const filterDays = getCurrentFilterDays();
                    dateRange = getDateRange(filterDays);
                }
               
                const [membersData, eventsData] = await Promise.all([
                    getTeamMembers(),
                    getFilteredEvents(dateRange.startDate, dateRange.endDate)
                ]);
               
                if (!membersData || !membersData.teamMembers) {
                    console.error('멤버 데이터를 가져올 수 없습니다.');
                    return;
                }
               
                await showInactiveMembersWithData(membersData, eventsData);
               
            } catch (error) {
                console.error('❌ 비활성 멤버 표시 실패:', error);
            }
        }

        // 활동 데이터를 타입별로 필터링 (실제 활동 기준) - 사용 중단됨
        // 이제 각 통계 카드 클릭 시 실제 API 데이터를 새로 가져와서 표시함
        function filterActivitiesByType(activities, type) {
            console.log(`⚠️ filterActivitiesByType 사용 중단됨. 대신 updateMembersByTypeWithRealData 사용`);
            console.log(`필터링 요청: ${type}, 전체 활동 수: ${activities.length}`);
           
            let filteredActivities;
            switch (type) {
                case 'active':
                    filteredActivities = activities.filter(activity => activity.type === 'active' && activity.request > 0);
                    break;
                case 'inactive':
                    // 비활성 멤버도 표시하도록 수정
                    filteredActivities = activities.filter(activity => activity.type === 'inactive');
                    break;
                case 'total':
                default:
                    filteredActivities = activities;
                    break;
            }
           
            console.log(`필터링 결과: ${filteredActivities.length}명`);
            return filteredActivities;
        }

        // Overview 활동리스트 제목 업데이트 (동적으로 헤더에 포함됨)
        function updateOverviewActivityTitle(type, count, totalCount) {
            // 제목은 renderOverviewActivityTableWithPagination에서 동적으로 생성됨
            let title, emoji;
            switch (type) {
                case 'active':
                    title = '활성 멤버 활동 리스트';
                    emoji = '✅';
                    break;
                case 'inactive':
                    title = '비활성 멤버 활동 리스트';
                    emoji = '💤';
                    break;
                case 'total':
                default:
                    title = '전체 활동 리스트';
                    emoji = '📊';
                    break;
            }
           
            // 동적으로 생성되는 제목에 사용될 기본 정보 반환
            return { title, emoji };
        }

        // 현재 Overview 필터 기간을 텍스트로 반환
        function getCurrentOverviewPeriodText() {
            let dateRange;
            if (currentDateRange) {
                dateRange = currentDateRange;
            } else {
                const filterDays = getCurrentFilterDays();
                dateRange = getDateRange(filterDays);
            }
            
            const startDate = new Date(dateRange.startDate).toLocaleDateString('ko-KR');
            const endDate = new Date(dateRange.endDate).toLocaleDateString('ko-KR');
            
            // 날짜 끝의 "." 제거
            const cleanStartDate = startDate.replace(/\.$/, '');
            const cleanEndDate = endDate.replace(/\.$/, '');
            
            return `${cleanStartDate} ~ ${cleanEndDate}`;
        }

        // 차트 버튼 클릭 이벤트
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('chart-btn')) {
                // 현재 섹션의 차트 버튼들만 처리
                const parentSection = e.target.closest('.content-section');
                if (parentSection) {
                    parentSection.querySelectorAll('.chart-btn').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    e.target.classList.add('active');
                   
                    // Overview 섹션의 필터 버튼인 경우 활동 리스트 업데이트
                    if (parentSection.id === 'overview') {
                        const days = e.target.getAttribute('data-days') || 1;
                        console.log(`Overview 필터 버튼 클릭: ${days}일`);
                        updateOverviewWithCurrentFilter();
                    }
                    // Usage 섹션의 필터 버튼인 경우 사용량 데이터 업데이트
                    else if (parentSection.id === 'usage') {
                        const days = e.target.getAttribute('data-days') || 30;
                        console.log(`Usage 필터 버튼 클릭: ${days}일`);
                        updateUsageWithCurrentFilter(days);
                    }
                }
            }
        });

        // 날짜 필터 적용 함수
        async function applyDateFilter() {
            const startDateInput = document.getElementById('start-date');
            const endDateInput = document.getElementById('end-date');
           
            if (!startDateInput.value || !endDateInput.value) {
                alert('시작 날짜와 종료 날짜를 모두 선택해주세요.');
                return;
            }
           
            const startDate = new Date(startDateInput.value).getTime();
            const endDate = new Date(endDateInput.value).getTime() + (24 * 60 * 60 * 1000 - 1); // 하루 끝까지
           
            if (startDate > endDate) {
                alert('시작 날짜는 종료 날짜보다 빠를 수 없습니다.');
                return;
            }
           
            console.log(`Overview 사용자 정의 날짜 범위 적용: ${new Date(startDate).toLocaleDateString()} ~ ${new Date(endDate).toLocaleDateString()}`);
           
            // 현재 날짜 범위 저장
            currentDateRange = { startDate, endDate };
           
            // 버튼 active 상태 제거
            document.querySelectorAll('#overview .chart-btn').forEach(btn => {
                btn.classList.remove('active');
            });
           
            // Overview 업데이트
            await updateOverviewWithCurrentFilter();
        }

        // Usage 날짜 필터 적용 함수
        async function applyUsageDateFilter() {
            const startDateInput = document.getElementById('usage-start-date');
            const endDateInput = document.getElementById('usage-end-date');
           
            if (!startDateInput.value || !endDateInput.value) {
                alert('시작 날짜와 종료 날짜를 모두 선택해주세요.');
                return;
            }
           
            const startDate = new Date(startDateInput.value).getTime();
            const endDate = new Date(endDateInput.value).getTime() + (24 * 60 * 60 * 1000 - 1); // 하루 끝까지
           
            if (startDate > endDate) {
                alert('시작 날짜는 종료 날짜보다 빠를 수 없습니다.');
                return;
            }
           
            console.log(`Usage 사용자 정의 날짜 범위 적용: ${new Date(startDate).toLocaleDateString()} ~ ${new Date(endDate).toLocaleDateString()}`);
           
            // 현재 날짜 범위 저장
            currentUsageDateRange = { startDate, endDate };
           
            // 버튼 active 상태 제거
            document.querySelectorAll('#usage .chart-btn').forEach(btn => {
                btn.classList.remove('active');
            });
           
            // Usage 업데이트
            await updateUsageWithDateRange(startDate, endDate);
        }

        // 현재 필터 설정으로 Overview 업데이트
        async function updateOverviewWithCurrentFilter() {
            try {
                console.log('=== 현재 필터로 Overview 업데이트 시작 ===');
               
                // 날짜 범위 결정
                let dateRange;
                if (currentDateRange) {
                    dateRange = currentDateRange;
                    console.log('사용자 정의 날짜 범위 사용');
                } else {
                    const filterDays = getCurrentFilterDays();
                    dateRange = getDateRange(filterDays);
                    console.log(`기본 필터 기간 사용: ${filterDays}일`);
                }
               
                // 팀원 정보 가져오기
                const membersData = await getTeamMembers();
                if (!membersData || !membersData.teamMembers) {
                    console.error('팀원 데이터를 가져올 수 없습니다.');
                    return;
                }
                currentMembers = membersData.teamMembers;
               
                // 활동 이벤트 가져오기
                const eventsData = await getFilteredEvents(dateRange.startDate, dateRange.endDate);
               
                // 지출 데이터로 통계 계산 (선택된 기간)
                const spendingData = await getTeamSpendingData();
               
                // 지출 데이터 매핑
                const memberSpendMap = {};
                if (spendingData && spendingData.teamMemberSpend) {
                    console.log('🔍 원본 지출 데이터:', spendingData.teamMemberSpend);
                    spendingData.teamMemberSpend.forEach(spendInfo => {
                        memberSpendMap[spendInfo.email] = {
                            premiumRequests: spendInfo.fastPremiumRequests || 0,
                            spend: (spendInfo.spendCents || 0) / 100,
                            hardLimitOverride: spendInfo.hardLimitOverrideDollars || 0
                        };
                        console.log(`💰 ${spendInfo.email}: requests=${spendInfo.fastPremiumRequests}, spend=$${((spendInfo.spendCents || 0) / 100).toFixed(2)}, limit=$${spendInfo.hardLimitOverrideDollars || 0}`);
                    });
                    console.log('📊 최종 지출 데이터 맵:', memberSpendMap);
                }
               
                if (eventsData && eventsData.usageEvents) {
                    console.log(`✅ ${eventsData.usageEvents.length}건의 활동 이벤트를 가져왔습니다.`);
                    currentActivities = createActivityListWithLastActivity(eventsData.usageEvents, membersData.teamMembers, memberSpendMap);
                   
                    // 선택된 기간 내 실제 활성 멤버 계산
                    const periodActiveMembers = calculatePeriodActiveMembers(eventsData.usageEvents);
                    const totalMembers = membersData.teamMembers.length;
                    const inactiveMembers = totalMembers - periodActiveMembers;
                   
                    console.log(`통계 계산 결과: 전체 ${totalMembers}명, 활성 ${periodActiveMembers}명, 비활성 ${inactiveMembers}명`);
                    console.log(`활동 리스트에 실제 표시될 멤버 수: ${currentActivities.length}명`);
                   
                    // 통계 카드 업데이트
                    updateStatsCards(totalMembers, periodActiveMembers, inactiveMembers);
                   
                    // 현재 선택된 타입에 따라 필터링
                    const filteredActivities = filterActivitiesByType(currentActivities, currentFilterType);
                    currentActivityPage = 1; // 페이지네이션 초기화
                    updateActivityList(filteredActivities);
                    // 제목은 동적으로 생성됨
                } else {
                    console.log('활동 이벤트 데이터가 없습니다.');
                    currentActivities = [];
                    const totalMembers = membersData ? membersData.teamMembers.length : 0;
                    updateStatsCards(totalMembers, 0, totalMembers);
                    currentActivityPage = 1; // 페이지네이션 초기화
                    updateActivityList([]);
                }
               
                console.log('=== 현재 필터로 Overview 업데이트 완료 ===');
            } catch (error) {
                console.error('❌ Overview 업데이트 실패:', error);
            }
        }

        // 선택된 기간 내 활성 멤버 수 계산 (실제 활동 기준)
        function calculatePeriodActiveMembers(events) {
            const activeUsers = new Set();
            events.forEach(event => {
                // 실제 활동이 있는 사용자만 카운트 (요청 비용이 0보다 크거나 토큰 기반 호출)
                if (event.userEmail && event.requestsCosts > 0) {
                    activeUsers.add(event.userEmail);
                }
            });
            console.log(`선택된 기간 내 활성 멤버: ${activeUsers.size}명`, Array.from(activeUsers));
            return activeUsers.size;
        }

        // Overview 활동 리스트만 업데이트 (기존 함수 호환성 유지)
        async function updateOverviewActivityList() {
            await updateOverviewWithCurrentFilter();
        }

        // 전체 실제 API 데이터 새로고침
        async function refreshAllRealData() {
            // 로딩 상태 표시
            showLoadingStatus(true);
           
            // Overview와 Members를 동시에 로드하여 시간 단축
            await Promise.all([
                updateOverviewWithRealData(),
                updateMembersWithRealData()
            ]);
           
            // 로딩 상태 해제
            showLoadingStatus(false);
        }

        // 최적화된 로딩 상태 표시/해제
        function showLoadingStatus(isLoading) {
            const pageTitle = document.getElementById('page-title');
           
            if (isLoading) {
                // Overview 섹션에서는 로딩 메시지를 표시하지 않음
                if (pageTitle.textContent === 'Overview' || pageTitle.textContent === 'Dashboard Overview') {
                    return;
                }
                pageTitle.innerHTML = '🔄 Loading Real API Data...';
            } else {
                // 원래 제목으로 복원
                if (pageTitle.textContent === '🔄 Loading Real API Data...') {
                    pageTitle.textContent = 'Dashboard Overview';
                }
            }
        }

        // 전역 변수
        let currentFilterType = 'total'; // 현재 선택된 필터 타입
        let currentActivities = []; // 현재 활동 데이터
        let currentMembers = []; // 현재 멤버 데이터
        let currentDateRange = null; // 현재 선택된 날짜 범위 (Overview용)
        let currentUsageDateRange = null; // 현재 선택된 날짜 범위 (Usage용)
        let currentRawEventsData = []; // 현재 Raw Events 전체 데이터
        let currentRawEventsPage = 1; // 현재 Raw Events 페이지
        let currentRawEventsPageSize = 10; // 현재 Raw Events 페이지 크기
        
        // Usage 데이터 로딩 상태 추적
        let isUsageDataLoaded = false; // Usage 데이터가 한 번이라도 로드되었는지 확인
        let isUsageLoading = false; // Usage 데이터 로딩 중인지 확인
        
        // 활동리스트 페이지네이션 변수
        let currentActivityPage = 1; // 현재 활동리스트 페이지
        let currentActivityPageSize = 20; // 현재 활동리스트 페이지 크기
        let currentActivityData = []; // 현재 활동리스트 데이터
        
        // 사용자별 누적 사용량 정보 페이지네이션 변수
        let currentUserCumulativePage = 1; // 현재 사용자별 누적 사용량 정보 페이지
        let currentUserCumulativePageSize = 20; // 현재 사용자별 누적 사용량 정보 페이지 크기
        let currentUserCumulativeData = []; // 현재 사용자별 누적 사용량 정보 데이터
        let currentUserCumulativeStartDate = null; // 현재 사용자별 누적 사용량 정보 시작 날짜
        let currentUserCumulativeEndDate = null; // 현재 사용자별 누적 사용량 정보 종료 날짜
        
        // Members 페이지네이션 변수
        let currentMembersPage = 1; // 현재 Members 페이지
        let currentMembersPageSize = 20; // 현재 Members 페이지 크기
        let currentMembersData = []; // 현재 Members 데이터
        let originalMembersData = []; // 원본 멤버 데이터 (필터링용)

        // ============================================================================
        // 성능 최적화 시스템 (2025.07.29 추가)
        // ============================================================================









        // API 호출을 위한 설정
        const API_CONFIG = {
            baseUrl: 'http://localhost:8001', // 로컬 프록시 서버
            apiKey: 'key_e46368ce482125bbd568b7d55090c657e30e4b73c824f522cbc9ef9b1bf3f0d3',
            headers: {
                'Content-Type': 'application/json'
            }
        };

        // API 호출 함수 (실제 API 호출)
        async function callAPI(endpoint, method = 'GET', data = null) {
            try {
                // Basic Auth 설정
                const credentials = `${API_CONFIG.apiKey}:`;
                const encodedCredentials = btoa(credentials);
                
                const options = {
                    method: method,
                    headers: {
                        ...API_CONFIG.headers,
                        'Authorization': `Basic ${encodedCredentials}`
                    }
                };

                if (data && method === 'POST') {
                    options.body = JSON.stringify(data);
                }

                console.log(`실제 Cursor Admin API 호출: ${method} ${API_CONFIG.baseUrl}${endpoint}`, data);
               
                const response = await fetch(API_CONFIG.baseUrl + endpoint, options);
               
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API 호출 실패: ${response.status} - ${response.statusText}\n${errorText}`);
                }

                const result = await response.json();
                console.log('실제 API 응답 데이터:', result);
               
                // API 응답에 오류가 있는지 확인
                if (result.error) {
                    throw new Error(`API 오류: ${result.error} - ${result.message}`);
                }
               
                return result;
               
            } catch (error) {
                console.error('API 호출 오류:', error);
                throw error; // 오류를 다시 던져서 호출자가 처리하도록 함
            }
        }



        // API 연결 상태 확인
        async function checkAPIConnection() {
            try {
                const response = await fetch(API_CONFIG.baseUrl + '/teams/members', {
                    method: 'GET',
                    headers: API_CONFIG.headers
                });
                return response.ok;
            } catch (error) {
                return false;
            }
        }

        // 팀원 정보 가져오기
        async function getTeamMembers() {
            return await callAPI('/teams/members');
        }

        // 사용량 데이터 가져오기
        async function getUsageData(startDate, endDate) {
            return await callAPI('/teams/daily-usage-data', 'POST', {
                startDate: startDate,
                endDate: endDate
            });
        }

        // 팀 지출 데이터 가져오기 (전체 멤버)
        async function getTeamSpendingData() {
            try {
                console.log('🔍 전체 멤버 지출 데이터 가져오기 시작...');
                
                // 직접 큰 pageSize로 모든 멤버 데이터 요청
                console.log('📡 API 호출: /teams/spend (pageSize: 1000)');
                const spendingData = await callAPI('/teams/spend', 'POST', {
                    page: 1,
                    pageSize: 1000
                });
                
                if (!spendingData || !spendingData.teamMemberSpend) {
                    throw new Error('지출 데이터를 가져올 수 없습니다.');
                }
                
                const retrievedCount = spendingData.teamMemberSpend.length;
                const totalMembers = spendingData.totalMembers || retrievedCount;
                const totalPages = spendingData.totalPages || 1;
                
                console.log(`✅ 지출 데이터 조회 완료:`);
                console.log(`   - 조회된 멤버: ${retrievedCount}명`);
                console.log(`   - 전체 멤버: ${totalMembers}명`);
                console.log(`   - 전체 페이지: ${totalPages}페이지`);
                
                // 모든 데이터를 가져왔는지 확인
                if (retrievedCount < totalMembers && totalPages > 1) {
                    console.log('⚠️ 추가 데이터가 있습니다. 더 큰 pageSize로 재요청...');
                    
                    const largerData = await callAPI('/teams/spend', 'POST', {
                        page: 1,
                        pageSize: Math.max(totalMembers + 100, 2000) // 여유있게 설정
                    });
                    
                    if (largerData && largerData.teamMemberSpend && largerData.teamMemberSpend.length > retrievedCount) {
                        console.log(`✅ 재요청 성공: ${largerData.teamMemberSpend.length}명의 데이터 확보`);
                        return largerData;
                    }
                }
                
                console.log(`🎯 최종 결과: ${retrievedCount}명의 멤버 데이터 반환`);
                return spendingData;
                
            } catch (error) {
                console.error('❌ 지출 데이터 가져오기 실패:', error);
                throw error;
            }
        }

        // 필터링된 이벤트 가져오기 (모든 페이지 데이터 수집)
        async function getFilteredEvents(startDate, endDate) {
            try {
                console.log('=== 필터링된 이벤트 데이터 가져오기 시작 ===');
                
                // 첫 번째 페이지 요청
                let allEvents = [];
                let currentPage = 1;
                let hasMorePages = true;
                
                while (hasMorePages) {
                    console.log(`📄 페이지 ${currentPage} 요청 중...`);
                    
                    const pageData = await callAPI('/teams/filtered-usage-events', 'POST', {
                        startDate: startDate,
                        endDate: endDate,
                        page: currentPage,
                        pageSize: 1000
                    });
                    
                    if (pageData && pageData.usageEvents) {
                        allEvents = allEvents.concat(pageData.usageEvents);
                        console.log(`✅ 페이지 ${currentPage}: ${pageData.usageEvents.length}개 이벤트 수집 (누적: ${allEvents.length}개)`);
                        
                        // 더 많은 페이지가 있는지 확인
                        hasMorePages = pageData.pagination && pageData.pagination.hasNextPage;
                        currentPage++;
                        
                        // 무한 루프 방지 (최대 10페이지)
                        if (currentPage > 10) {
                            console.log('⚠️ 최대 페이지 수 도달 - 무한 루프 방지');
                            break;
                        }
                    } else {
                        console.log(`❌ 페이지 ${currentPage} 데이터 없음`);
                        hasMorePages = false;
                    }
                }
                
                console.log(`=== 필터링된 이벤트 데이터 수집 완료: 총 ${allEvents.length}개 이벤트 ===`);
                
                // 기존 형식으로 반환
                return {
                    totalUsageEventsCount: allEvents.length,
                    usageEvents: allEvents,
                    period: {
                        startDate: startDate,
                        endDate: endDate
                    }
                };
                
            } catch (error) {
                console.error('❌ 필터링된 이벤트 가져오기 실패:', error);
                throw error;
            }
        }

        // 현재 선택된 필터 기간 가져오기
        function getCurrentFilterDays() {
            const activeBtn = document.querySelector('#overview .chart-btn.active');
            if (!activeBtn) return 30; // 기본값 30일
           
            const days = activeBtn.getAttribute('data-days');
            return days ? parseInt(days) : 30;
        }

        // 날짜를 epoch milliseconds로 변환
        function getDateRange(days = 7) {
            const endDate = new Date();
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - days);
           
            return {
                startDate: startDate.getTime(),
                endDate: endDate.getTime()
            };
        }

        // Overview 데이터 업데이트 (초기 로드용)
        async function updateOverviewWithRealData() {
            try {
                console.log('=== 실제 Cursor Admin API 데이터로 Overview 초기 로드 시작 ===');
               
                // 초기화
                currentFilterType = 'total';
                currentDateRange = null;
               
                // 현재 필터로 업데이트
                await updateOverviewWithCurrentFilter();

                // 차트 데이터 생성 (최근 7일 사용량 데이터)
                console.log('차트용 일별 사용량 데이터 API 호출 중...');
                const chartDateRange = getDateRange(7);
                const usageData = await getUsageData(chartDateRange.startDate, chartDateRange.endDate);
               
                if (usageData && usageData.data) {
                    const chartData = createChartData(usageData.data);
                    updateChart(chartData);
                    console.log(`✅ ${usageData.data.length}건의 차트 데이터를 처리했습니다.`);
                    
                    // 사용량 카드 업데이트 (Overview 섹션의 카드들도 포함)
                    console.log('사용량 카드 업데이트 중...');
                    const eventsData = await getFilteredEvents(chartDateRange.startDate, chartDateRange.endDate);
                    updateUsageCards(usageData, eventsData);
                    console.log('✅ 사용량 카드 업데이트 완료');
                }

                // 필터 기간 표시
                updateFilterPeriod(chartDateRange.startDate, chartDateRange.endDate);

                // 초기 로드 후 기본 선택된 'total' 카드에 맞는 실제 데이터 표시
                console.log('초기 로드 후 전체 멤버 데이터 표시');
                await updateMembersByTypeWithRealData('total');
               
                // 선택 상태와 데이터 일치 확인
                console.log(`현재 선택된 타입: ${currentFilterType}`);
                console.log('전체 멤버 카드 선택 상태 확인 완료');

                console.log('=== 실제 API 데이터로 Overview 초기 로드 완료! ===');
            } catch (error) {
                console.error('❌ Overview 초기 로드 실패:', error);
                alert('Overview 데이터를 불러오는데 실패했습니다. 네트워크 연결과 API 서버 상태를 확인해주세요.');
            }
        }

        // 통계 카드 업데이트 (실제 API 데이터 사용)
        function updateStatsCards(total, active, inactive) {
            const totalBox = document.querySelector('.overview-stat-box[data-type="total"] .stat-number');
            const activeBox = document.querySelector('.overview-stat-box[data-type="active"] .stat-number');
            const inactiveBox = document.querySelector('.overview-stat-box[data-type="inactive"] .stat-number');

            if (totalBox) {
                totalBox.textContent = total;
                console.log(`✅ 총 멤버 수 업데이트: ${total}명`);
            }
            if (activeBox) {
                activeBox.textContent = active;
                console.log(`✅ 활성 멤버 수 업데이트: ${active}명`);
            }
            if (inactiveBox) {
                inactiveBox.textContent = inactive;
                console.log(`✅ 비활성 멤버 수 업데이트: ${inactive}명`);
            }

            // 멤버 수 카운터 업데이트
            const memberCount = document.getElementById('member-count');
            if (memberCount) {
                memberCount.textContent = `(${total}명)`;
            }
        }

        // 차트 데이터 생성 (일별 집계)
        function createChartData(usageData) {
            const dailyTotals = {};
           
            // 일별로 모든 사용자의 활동 집계
            usageData.forEach(dayData => {
                const dateKey = new Date(dayData.date).toDateString();
               
                if (!dailyTotals[dateKey]) {
                    dailyTotals[dateKey] = {
                        date: dayData.date,
                        totalApplies: 0,
                        totalAccepts: 0,
                        chatRequests: 0,
                        agentRequests: 0
                    };
                }
               
                dailyTotals[dateKey].totalApplies += (dayData.totalApplies || 0);
                dailyTotals[dateKey].totalAccepts += (dayData.totalAccepts || 0);
                dailyTotals[dateKey].chatRequests += (dayData.chatRequests || 0);
                dailyTotals[dateKey].agentRequests += (dayData.agentRequests || 0);
            });
           
            // 차트 데이터 생성
            const chartData = Object.values(dailyTotals)
                .sort((a, b) => a.date - b.date)
                .map(dayTotal => {
                    const date = new Date(dayTotal.date);
                    const activityScore = dayTotal.totalApplies + dayTotal.totalAccepts +
                                        dayTotal.chatRequests + dayTotal.agentRequests;
                   
                    return {
                        date: date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
                        activity: activityScore,
                        applies: dayTotal.totalApplies,
                        accepts: dayTotal.totalAccepts,
                        chats: dayTotal.chatRequests,
                        agents: dayTotal.agentRequests
                    };
                });

            console.log('차트 데이터 생성:', chartData);
            return chartData;
        }

        // 차트 업데이트
        function updateChart(chartData) {
            const canvas = document.getElementById('overviewChart');
            if (!canvas || !chartData.length) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // 기존 차트 지우기
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);

            // 그리드 그리기
            ctx.strokeStyle = '#3a3a3a';
            ctx.lineWidth = 1;
           
            // 세로 그리드
            for (let i = 0; i <= chartData.length; i++) {
                const x = (width / chartData.length) * i;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }

            // 가로 그리드
            for (let i = 0; i <= 5; i++) {
                const y = (height / 5) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // 데이터 포인트 계산
            const maxActivity = Math.max(...chartData.map(d => d.activity));
            const dataPoints = chartData.map((data, index) => ({
                x: (width / (chartData.length - 1)) * index,
                y: height - (height * (data.activity / maxActivity))
            }));

            // 선 그래프 그리기
            if (dataPoints.length > 1) {
                ctx.strokeStyle = '#4a9eff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(dataPoints[0].x, dataPoints[0].y);
               
                for (let i = 1; i < dataPoints.length; i++) {
                    ctx.lineTo(dataPoints[i].x, dataPoints[i].y);
                }
                ctx.stroke();
            }

            // 데이터 포인트 원 그리기
            dataPoints.forEach(point => {
                ctx.fillStyle = '#4a9eff';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 4, 0, Math.PI * 2);
                ctx.fill();
            });

            // 날짜 레이블
            ctx.fillStyle = '#7a7a7a';
            ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.textAlign = 'center';
           
            chartData.forEach((data, index) => {
                const x = (width / (chartData.length - 1)) * index;
                ctx.fillText(data.date, x, height - 10);
            });
        }

        // 활동 리스트 생성 (실제 활동이 있는 멤버만, 정확한 통계 반영)
        function createActivityListWithLastActivity(events, members, memberSpendMap = {}) {
            console.log('=== 활동 리스트 생성 시작 ===');
            console.log(`전체 이벤트 수: ${events.length}개`);
            console.log(`전체 멤버 수: ${members.length}명`);
            console.log('지출 데이터 맵:', memberSpendMap);
           
            // 사용자별 마지막 활동 날짜 및 통계 계산
            const userActivity = {};
           
            events.forEach(event => {
                const userEmail = event.userEmail;
                const timestamp = parseInt(event.timestamp);
                const requestCost = event.requestsCosts || 0;
               
                if (!userActivity[userEmail]) {
                    userActivity[userEmail] = {
                        lastTimestamp: timestamp,
                        totalRequests: 0,
                        events: []
                    };
                }
               
                // 마지막 활동 시간 업데이트
                if (timestamp > userActivity[userEmail].lastTimestamp) {
                    userActivity[userEmail].lastTimestamp = timestamp;
                }
               
                // 요청 수만 누적 (실제 지출은 /teams/spend API에서 가져옴)
                userActivity[userEmail].totalRequests += requestCost;
                userActivity[userEmail].events.push(event);
            });
           
            console.log('사용자별 활동 통계:', userActivity);
           
            // 모든 멤버를 포함하여 활동 정보 생성 (활성 + 비활성)
            const activities = [];
            let activeCount = 0;
            let inactiveCount = 0;
           
            members.forEach(member => {
                const userStats = userActivity[member.email];
                const spendData = memberSpendMap[member.email] || {};
                
                // 실제 지출 데이터 사용 (/teams/spend API에서)
                const actualSpend = spendData.spend || 0;
                const premiumRequests = spendData.premiumRequests || 0;
                const hardLimit = spendData.hardLimitOverride || 0;
                const limitDisplay = hardLimit > 0 ? `$${hardLimit}` : '$0';
               
                if (userStats && userStats.totalRequests > 0) {
                    // 활동이 있는 멤버
                    const lastActivityDate = new Date(userStats.lastTimestamp);
                   
                    // 오늘 날짜 기준으로 정확한 일수 차이 계산
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                   
                    const activityDate = new Date(userStats.lastTimestamp);
                    activityDate.setHours(0, 0, 0, 0);
                   
                    const daysDiff = Math.floor((today - activityDate) / (1000 * 60 * 60 * 24));
                   
                    activeCount++;
                   
                    activities.push({
                        date: lastActivityDate.toLocaleDateString('ko-KR', {
                            month: '2-digit',
                            day: '2-digit'
                        }) + ` (${daysDiff === 0 ? '오늘' : daysDiff + '일 전'})`,
                        timestamp: userStats.lastTimestamp,
                        email: member.email,
                        name: member.name || 'Unnamed',
                        type: 'active',
                        kind: userStats.events.length > 0 ? userStats.events[0].kindLabel || 'Unknown' : 'Unknown',
                        request: premiumRequests, // Premium Requests 사용
                        spend: `$${actualSpend.toFixed(2)}`, // 실제 지출 데이터 사용
                        limit: limitDisplay
                    });
                } else {
                    // 활동이 없는 멤버 (비활성)
                    inactiveCount++;
                   
                    activities.push({
                        date: 'No Activity',
                        timestamp: 0,
                        email: member.email,
                        name: member.name || 'Unnamed',
                        type: 'inactive',
                        kind: 'No Activity',
                        request: 0,
                        spend: `$${actualSpend.toFixed(2)}`, // 실제 지출 데이터 사용
                        limit: limitDisplay
                    });
                }
            });
           
            console.log(`활동 리스트 결과: 총 ${activities.length}명 (활성: ${activeCount}명, 비활성: ${inactiveCount}명)`);
           
            // 마지막 활동 날짜 기준으로 정렬 (최신순 - 내림차순)
            return activities.sort((a, b) => {
                return b.timestamp - a.timestamp;
            });
        }

        // 기존 활동 리스트 생성 (호환성 유지)
        function createActivityList(events) {
            return events.slice(0, 20).map(event => {
                const timestamp = new Date(parseInt(event.timestamp));
                return {
                    date: timestamp.toLocaleDateString('ko-KR', {
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit'
                    }),
                    email: event.userEmail || 'Unknown',
                    type: event.isTokenBasedCall ? 'active' : 'inactive',
                    kind: event.kindLabel || 'Unknown',
                    request: event.requestsCosts || 0,
                    spend: event.isTokenBasedCall ?
                        `$${(event.tokenUsage?.totalCents || 0) / 100}` :
                        '$0.00'
                };
            });
        }



        // 이메일 클릭 시 Usage 섹션으로 이동 및 검색
        function navigateToUsageWithEmail(email) {
            console.log(`이메일 클릭: ${email} - Usage 섹션으로 이동 시작`);
            
            // 검색 예정 플래그 설정 (자동 새로고침 방지용)
            window.pendingEmailSearch = email;
            
            // 수동으로 섹션 전환 (자동 데이터 로드 방지)
            const usageMenuItem = document.querySelector('.menu-item[data-section="usage"]');
            const allMenuItems = document.querySelectorAll('.menu-item');
            const allSections = document.querySelectorAll('.content-section');
            
            // 메뉴 상태 업데이트
            allMenuItems.forEach(menu => menu.classList.remove('active'));
            if (usageMenuItem) {
                usageMenuItem.classList.add('active');
            }
            
            // 섹션 전환
            allSections.forEach(section => section.classList.remove('active'));
            const usageSection = document.getElementById('usage');
            if (usageSection) {
                usageSection.classList.add('active');
            }
            
            // 페이지 제목 업데이트
            const pageTitle = document.getElementById('page-title');
            if (pageTitle) {
                pageTitle.textContent = 'Usage Analytics';
            }
            
            // Usage 데이터가 이미 로드되어 있는지 확인
            const hasData = currentRawEventsData && currentRawEventsData.length > 0;
            
            if (hasData) {
                // 데이터가 이미 있으면 즉시 검색 실행
                executeEmailSearch(email);
            } else {
                // 데이터가 없으면 먼저 로드한 후 검색
                console.log('Usage 데이터를 먼저 로드합니다...');
                updateUsageWithCurrentFilter(30).then(() => {
                    // 데이터 로드 완료 후 검색 실행
                    setTimeout(() => {
                        executeEmailSearch(email);
                    }, 500);
                }).catch(error => {
                    console.error('Usage 데이터 로드 실패:', error);
                    // 로드 실패해도 검색은 시도
                    executeEmailSearch(email);
                });
            }
            
            console.log(`📧 이메일 클릭 처리 완료: ${email}`);
        }
        
        // 이메일 검색 실행 함수
        function executeEmailSearch(email) {
            const searchBox = document.querySelector('#usage .search-box');
            if (searchBox) {
                searchBox.value = email;
                // X 버튼 표시
                toggleSearchClearBtn('usage-search');
                filterUsageMembers(email);
                console.log(`✅ 이메일 검색 완료: ${email}`);
                
                // 검색 완료 후 플래그 제거
                delete window.pendingEmailSearch;
            } else {
                console.error('❌ Usage 섹션의 검색창을 찾을 수 없습니다.');
            }
        }

        // 활동 리스트 업데이트 (Members 스타일 페이지네이션)
        function updateActivityList(activities) {
            currentActivityData = activities; // 데이터 저장
            renderOverviewActivityTableWithPagination(activities);
        }

        // Overview 활동리스트 테이블 렌더링 (Members 스타일)
        function renderOverviewActivityTableWithPagination(activities) {
            // 헤더 업데이트
            const headerElement = document.querySelector('.overview-activity-header');
            if (headerElement) {
                if (!activities || activities.length === 0) {
                    headerElement.innerHTML = '📋 활동 리스트';
                } else {
                    const totalActivities = activities.length;
                    const totalPages = Math.ceil(totalActivities / currentActivityPageSize);
                    const startIndex = (currentActivityPage - 1) * currentActivityPageSize;
                    const endIndex = Math.min(startIndex + currentActivityPageSize, totalActivities);
                    
                    // 현재 필터 타입에 따른 제목 결정
                    const titleInfo = updateOverviewActivityTitle(currentFilterType, totalActivities, totalActivities);
                    const periodText = getCurrentOverviewPeriodText();
                    
                    headerElement.innerHTML = `
                        <span>${titleInfo.emoji} ${titleInfo.title} (${periodText})(${startIndex + 1}-${endIndex} of ${totalActivities})</span>
                        <select id="overviewActivityPageSize" onchange="changeOverviewActivityPageSize(this.value)" style="background: #3a3a3a; color: #fff; border: 1px solid #4a4a4a; padding: 5px 10px; border-radius: 4px; font-size: 12px;">
                            <option value="10" ${currentActivityPageSize === 10 ? 'selected' : ''}>10개 보기</option>
                            <option value="20" ${currentActivityPageSize === 20 ? 'selected' : ''}>20개 보기</option>
                            <option value="30" ${currentActivityPageSize === 30 ? 'selected' : ''}>30개 보기</option>
                            <option value="50" ${currentActivityPageSize === 50 ? 'selected' : ''}>50개 보기</option>
                            <option value="100" ${currentActivityPageSize === 100 ? 'selected' : ''}>100개 보기</option>
                        </select>
                    `;
                }
            }
            
            if (!activities || activities.length === 0) {
                const container = document.getElementById('overview-activity-container');
                if (container) {
                    container.innerHTML = `
                        <div style="padding: 20px; text-align: center; color: #7a7a7a; background-color: #1a1a1a;">
                            활동 데이터가 없습니다.
                        </div>
                    `;
                }
                // 페이지네이션 숨기기
                const pagination = document.getElementById('overview-activity-pagination');
                if (pagination) pagination.style.display = 'none';
                return;
            }

            // 페이지네이션 계산
            const totalActivities = activities.length;
            const totalPages = Math.ceil(totalActivities / currentActivityPageSize);
            const startIndex = (currentActivityPage - 1) * currentActivityPageSize;
            const endIndex = Math.min(startIndex + currentActivityPageSize, totalActivities);
            const pageActivities = activities.slice(startIndex, endIndex);

            console.log(`📄 Overview 활동리스트 페이지네이션: ${startIndex + 1}-${endIndex} of ${totalActivities} (페이지 ${currentActivityPage}/${totalPages})`);

            // 테이블 내용만 업데이트
            const tableContent = pageActivities.map(activity => `
                <div class="member-item">
                    <div class="member-date">${activity.date}</div>
                    <div class="member-email clickable-email" title="View usage for ${activity.email}" onclick="navigateToUsageWithEmail('${activity.email}')">${activity.email}</div>
                    <div class="member-type ${activity.type}">${activity.type === 'active' ? '활성' : '비활성'}</div>
                    <div class="member-kind">${activity.kind}</div>
                    <div class="member-request">${activity.request}</div>
                    <div class="member-spend">${activity.spend}</div>
                    <div class="member-limit">${activity.limit || '$0'}</div>
                </div>
            `).join('');

            // 컨테이너에 테이블 내용만 삽입
            const container = document.getElementById('overview-activity-container');
            if (container) {
                container.innerHTML = tableContent;
            }

            // 페이지네이션 업데이트
            const paginationContainer = document.getElementById('overview-activity-pagination');
            if (paginationContainer && totalPages > 1) {
                paginationContainer.innerHTML = generateOverviewActivityPagination(totalPages);
                paginationContainer.style.display = 'block';
            } else if (paginationContainer) {
                paginationContainer.style.display = 'none';
            }
           
            // 통계 업데이트
            const activeCount = activities.filter(a => a.type === 'active').length;
            const totalRequests = activities.reduce((sum, a) => sum + (typeof a.request === 'number' ? a.request : 0), 0);
           
            console.log(`📊 Overview 활동 리스트 업데이트: 총 ${activities.length}명, 활성 ${activeCount}명, 총 요청 ${totalRequests}건 (페이지 ${currentActivityPage}/${totalPages})`);
        }



        // 필터 기간 업데이트
        function updateFilterPeriod(startDate, endDate) {
            const start = new Date(startDate).toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric'
            });
            const end = new Date(endDate).toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric'
            });
           
            const dateFilterBtn = document.querySelector('.date-filter-btn');
            if (dateFilterBtn) {
                dateFilterBtn.textContent = `${start} - ${end}`;
            }
        }



        // 멤버 테이블을 실제 API 데이터로 업데이트
        async function updateMembersWithRealData() {
            try {
                console.log('=== 실제 Cursor Admin API 데이터로 멤버 테이블 업데이트 시작 ===');
               
                // 1. 실제 팀원 정보 가져오기
                console.log('1. 팀원 정보 API 호출 중...');
                const membersData = await getTeamMembers();
                console.log('팀원 데이터 응답:', membersData);
               
                if (!membersData || !membersData.teamMembers) {
                    throw new Error('팀원 데이터를 가져올 수 없습니다.');
                }

                console.log(`✅ 총 ${membersData.teamMembers.length}명의 팀원 정보를 가져왔습니다.`);

                // 2. 실제 지출 데이터 가져오기 (올바른 API 사용)
                console.log('2. 팀 지출 데이터 API 호출 중... (/teams/spend)');
                const spendingData = await getTeamSpendingData();
                console.log('지출 데이터 응답:', spendingData);
               
                if (!spendingData || !spendingData.teamMemberSpend) {
                    throw new Error('지출 데이터를 가져올 수 없습니다.');
                }

                console.log(`✅ ${spendingData.teamMemberSpend.length}명의 지출 데이터를 가져왔습니다.`);
                console.log(`📊 API 응답 정보: 총 멤버 ${spendingData.totalMembers || '정보없음'}명, 총 페이지 ${spendingData.totalPages || '정보없음'}개`);
                
                // 실제로 가져온 멤버 수와 API 멤버 수 비교 로깅
                if (membersData.teamMembers.length !== spendingData.teamMemberSpend.length) {
                    console.log(`⚠️ 멤버 수 불일치: 멤버 API ${membersData.teamMembers.length}명 vs 지출 API ${spendingData.teamMemberSpend.length}명`);
                }

                // 3. 이메일 기준으로 멤버와 지출 데이터 매핑
                console.log('3. 멤버와 지출 데이터 매핑 중...');
                const memberSpendMap = {};
               
                spendingData.teamMemberSpend.forEach(spendInfo => {
                    memberSpendMap[spendInfo.email] = {
                        premiumRequests: spendInfo.fastPremiumRequests || 0,
                        spend: (spendInfo.spendCents || 0) / 100, // cents를 dollars로 변환
                        hardLimitOverride: spendInfo.hardLimitOverrideDollars || 0
                    };
                });

                console.log('지출 데이터 매핑 결과:', memberSpendMap);

                // 4. Fast Requests 리셋 날짜 표시
                console.log('4. Fast Requests 리셋 날짜 표시 중...');
                updateFastRequestsResetDate(spendingData.teamMemberSpend);
                
                // 5. 멤버 테이블 업데이트
                console.log('5. 멤버 테이블 UI 업데이트 중...');
                updateMembersTable(membersData.teamMembers, memberSpendMap);
               
                console.log('=== 실제 API 데이터로 멤버 테이블 업데이트 완료! ===');
               
            } catch (error) {
                console.error('❌ 실제 API 데이터 로드 실패:', error);
                
                // 사용자에게 알림
                alert(`실제 API 데이터 로드에 실패했습니다:\n${error.message}\n\n프록시 서버가 실행 중인지 확인하세요.`);
            }
        }

        // Fast Requests 리셋 날짜 표시
        function updateFastRequestsResetDate(teamMemberSpend) {
            try {
                // Premium Requests가 0인 멤버들을 찾아서 리셋 날짜 계산
                const zeroRequestMembers = teamMemberSpend.filter(member => 
                    member.fastPremiumRequests === 0
                );
                
                // 실제로는 API에서 제공하는 리셋 날짜 정보가 필요하지만,
                // 현재로서는 고정된 날짜를 사용
                const resetDate = '2025년 7월 22일';
                
                const resetDateElement = document.getElementById('fast-requests-reset-date');
                if (resetDateElement) {
                    resetDateElement.textContent = resetDate;
                }
                
                // 한국 시간 기준 오늘 날짜 업데이트
                updateTodayDate();
                
                console.log(`📅 Fast Requests 리셋 날짜: ${resetDate} (Premium Requests 0인 멤버: ${zeroRequestMembers.length}명)`);
            } catch (error) {
                console.error('❌ Fast Requests 리셋 날짜 계산 오류:', error);
                const resetDateElement = document.getElementById('fast-requests-reset-date');
                if (resetDateElement) {
                    resetDateElement.textContent = '2025년 7월 22일';
                }
                // 오류 발생 시에도 오늘 날짜는 업데이트
                updateTodayDate();
            }
        }

        // 한국 시간 기준 오늘 날짜 업데이트
        function updateTodayDate() {
            try {
                // 한국 시간 기준 (UTC+9)
                const now = new Date();
                const koreaTime = new Date(now.getTime() + (9 * 60 * 60 * 1000)); // UTC+9
                const todayDate = koreaTime.toISOString().split('T')[0]; // YYYY-MM-DD 형식
                
                const todayDateElement = document.getElementById('today-date');
                if (todayDateElement) {
                    todayDateElement.textContent = todayDate;
                    todayDateElement.style.color = '#ff9800'; // 오렌지색
                }
                
                console.log(`📅 오늘 날짜 (한국 시간): ${todayDate}`);
            } catch (error) {
                console.error('❌ 오늘 날짜 계산 오류:', error);
                const todayDateElement = document.getElementById('today-date');
                if (todayDateElement) {
                    todayDateElement.textContent = '2025-08-03';
                    todayDateElement.style.color = '#ff9800'; // 오렌지색
                }
            }
        }

        // Export CSV 기능
        function exportMembersToCSV() {
            try {
                if (!currentMembersData || currentMembersData.length === 0) {
                    alert('내보낼 멤버 데이터가 없습니다.');
                    return;
                }
                
                // CSV 헤더
                const headers = ['Name', 'Email', 'Role', 'Premium Requests', 'Spend ($)', 'Hard Limit Override ($)'];
                
                // CSV 데이터 생성
                const csvData = currentMembersData.map(member => [
                    member.name || '',
                    member.email || '',
                    member.role || '',
                    member.spendData?.premiumRequests || 0,
                    (member.spendData?.spend || 0).toFixed(2),
                    (member.spendData?.hardLimitOverride || 0).toFixed(2)
                ]);
                
                // CSV 문자열 생성
                const csvContent = [
                    headers.join(','),
                    ...csvData.map(row => row.join(','))
                ].join('\n');
                
                // 파일 다운로드
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', `members_export_${new Date().toISOString().split('T')[0]}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                console.log(`📊 CSV 내보내기 완료: ${currentMembersData.length}명의 멤버 데이터`);
            } catch (error) {
                console.error('❌ CSV 내보내기 오류:', error);
                alert('CSV 내보내기에 실패했습니다.');
            }
        }

        // 멤버 테이블 업데이트 (실제 지출 데이터 사용)
        function updateMembersTable(members, memberSpendMap) {
            console.log(`🔄 멤버 테이블 업데이트 시작: ${members.length}명의 멤버 데이터`);
            console.log('📊 지출 데이터 매핑 정보:', Object.keys(memberSpendMap));
           
            // 멤버 정보와 실제 지출 데이터 결합
            const membersWithSpending = members.map(member => {
                const spendData = memberSpendMap[member.email] || {
                    premiumRequests: 0,
                    spend: 0,
                    hardLimitOverride: 0
                };
               
                return {
                    ...member,
                    spendData: spendData
                };
            });
           
            console.log(`📋 처리된 멤버 데이터: ${membersWithSpending.length}명`);
           
            // Premium Requests 기준으로 정렬 (높은 순)
            membersWithSpending.sort((a, b) => b.spendData.premiumRequests - a.spendData.premiumRequests);
           
            // 전역 데이터 저장
            currentMembersData = membersWithSpending;
            originalMembersData = [...membersWithSpending]; // 원본 데이터 보존
            currentMembersPage = 1; // 페이지 리셋
            
            // 페이지네이션과 함께 렌더링
            renderMembersTableWithPagination(membersWithSpending);
        }
        
        // Members 테이블 페이지네이션과 함께 렌더링 (All Raw Events 스타일)
        function renderMembersTableWithPagination(membersWithSpending) {
            const tableContainer = document.querySelector('#members-table-container');
            if (!tableContainer) {
                console.error('❌ 멤버 테이블 컨테이너를 찾을 수 없습니다.');
                return;
            }
            
            // 페이지네이션 적용
            const totalMembers = membersWithSpending.length;
            const totalPages = Math.ceil(totalMembers / currentMembersPageSize);
            const startIndex = (currentMembersPage - 1) * currentMembersPageSize;
            const endIndex = Math.min(startIndex + currentMembersPageSize, totalMembers);
            const pageMembers = membersWithSpending.slice(startIndex, endIndex);
            
            console.log(`📄 페이지네이션: ${startIndex + 1}-${endIndex} of ${totalMembers} (페이지 ${currentMembersPage}/${totalPages})`);
           
            // 테이블 제목 동적 생성
            const getTableTitle = () => {
                if (currentFilterType === 'active') {
                    return `👥 활성 멤버 보기 (${startIndex + 1}-${endIndex} of ${totalMembers})`;
                } else if (currentFilterType === 'inactive') {
                    return `👥 비활성 멤버 보기 (${startIndex + 1}-${endIndex} of ${totalMembers})`;
                } else {
                    return `👥 전체 멤버 보기 (${startIndex + 1}-${endIndex} of ${totalMembers})`;
                }
            };

            // 테이블 HTML 생성 (All Raw Events 스타일)
            const tableHtml = `
                <div class="user-cumulative-header" style="display: flex; justify-content: space-between; align-items: center;">
                    <span>${getTableTitle()}</span>
                    <select id="membersPageSize" onchange="changeMembersPageSize(this.value)" style="background: #3a3a3a; color: #fff; border: 1px solid #4a4a4a; padding: 5px 10px; border-radius: 4px; font-size: 12px;">
                        <option value="10" ${currentMembersPageSize === 10 ? 'selected' : ''}>10개 보기</option>
                        <option value="20" ${currentMembersPageSize === 20 ? 'selected' : ''}>20개 보기</option>
                        <option value="30" ${currentMembersPageSize === 30 ? 'selected' : ''}>30개 보기</option>
                        <option value="50" ${currentMembersPageSize === 50 ? 'selected' : ''}>50개 보기</option>
                        <option value="100" ${currentMembersPageSize === 100 ? 'selected' : ''}>100개 보기</option>
                    </select>
                </div>
                <div class="table-header">
                    <div onclick="sortMembers('name')" style="cursor: pointer;">NAME ↕</div>
                    <div onclick="sortMembers('email')" style="cursor: pointer;">EMAIL ↕</div>
                    <div onclick="sortMembers('requests')" style="cursor: pointer;">PREMIUM REQUESTS ↕</div>
                    <div onclick="sortMembers('spend')" style="cursor: pointer;">SPEND ↕</div>
                    <div onclick="sortMembers('role')" style="cursor: pointer;">ROLE ↕</div>
                    <div></div>
                </div>
                ${pageMembers.length > 0 ? pageMembers.map(member => {
                const roleBadgeClass = member.role === 'owner' ? 'admin' : '';
                const roleText = member.role === 'owner' ? 'Admin' : 'Member';
                const requestColor = member.spendData.premiumRequests > 100 ? '#4caf50' :
                                   member.spendData.premiumRequests > 20 ? '#ff9800' :
                                   member.spendData.premiumRequests > 0 ? '#2196f3' : '#f44336';
               
                    return `
                        <div class="table-row">
                    <div>${member.name || 'Unnamed'}</div>
                    <div class="clickable-email" title="View usage for ${member.email}" onclick="navigateToUsageWithEmail('${member.email}')">${member.email}</div>
                    <div style="color: ${requestColor}; font-weight: 600;">${member.spendData.premiumRequests}</div>
                    <div>$${member.spendData.spend.toFixed(2)}</div>
                    <div><span class="role-badge ${roleBadgeClass}">${roleText}</span></div>
                    <div>⋯</div>
                        </div>
                    `;
                }).join('') : '<div style="padding: 20px; text-align: center; color: #7a7a7a; background-color: #1a1a1a; grid-column: 1 / -1;">멤버 데이터가 없습니다.</div>'}
            `;
            
            tableContainer.innerHTML = tableHtml;
            
            // 페이지네이션 표시/숨김
            const paginationContainer = document.getElementById('members-pagination');
            if (paginationContainer) {
                if (totalMembers > currentMembersPageSize) {
                    paginationContainer.style.display = 'block';
                    paginationContainer.innerHTML = generateMembersPagination(totalPages);
                } else {
                    paginationContainer.style.display = 'none';
                }
            }
            
            console.log(`✅ Members 테이블 업데이트 완료: 페이지 ${currentMembersPage}/${totalPages}, ${pageMembers.length}개 멤버 표시`);
           
            // 통계 정보 표시
            const totalRequests = membersWithSpending.reduce((sum, member) => sum + member.spendData.premiumRequests, 0);
            const totalSpend = membersWithSpending.reduce((sum, member) => sum + member.spendData.spend, 0);
            const activeMembers = membersWithSpending.filter(member => member.spendData.premiumRequests > 0).length;
           
            console.log(`📊 멤버 통계 (실제 API 데이터):`);
            console.log(`   - 총 멤버: ${membersWithSpending.length}명`);
            console.log(`   - 활성 멤버: ${activeMembers}명 (Premium Requests > 0)`);
            console.log(`   - 총 Premium Requests: ${totalRequests}건`);
            console.log(`   - 총 지출: $${totalSpend.toFixed(2)}`);
        }
        
        // 사용자별 누적 사용량 정보 페이지네이션 생성 (All Raw Events 스타일)
        function generateUserCumulativePagination(totalPages) {
            let pagination = '';
            
            // 이전 버튼
            if (currentUserCumulativePage > 1) {
                pagination += `<button onclick="changeUserCumulativePage(${currentUserCumulativePage - 1})" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; margin: 0 2px;">‹</button>`;
            }
            
            // 페이지 번호들
            let startPage = Math.max(1, currentUserCumulativePage - 2);
            let endPage = Math.min(totalPages, currentUserCumulativePage + 2);
            
            // 첫 페이지가 범위에 없으면 추가
            if (startPage > 1) {
                pagination += `<button onclick="changeUserCumulativePage(1)" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; margin: 0 2px;">1</button>`;
                if (startPage > 2) {
                    pagination += `<span style="color: #7a7a7a; padding: 0 5px;">...</span>`;
                }
            }
            
            // 현재 범위의 페이지들
            for (let i = startPage; i <= endPage; i++) {
                const isActive = i === currentUserCumulativePage;
                pagination += `<button onclick="changeUserCumulativePage(${i})" style="background: ${isActive ? '#4a9eff' : '#3a3a3a'}; border: 1px solid ${isActive ? '#4a9eff' : '#4a4a4a'}; color: ${isActive ? 'white' : '#e1e1e1'}; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: ${isActive ? '600' : 'normal'}; margin: 0 2px;">${i}</button>`;
            }
            
            // 마지막 페이지가 범위에 없으면 추가
            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    pagination += `<span style="color: #7a7a7a; padding: 0 5px;">...</span>`;
                }
                pagination += `<button onclick="changeUserCumulativePage(${totalPages})" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; margin: 0 2px;">${totalPages}</button>`;
            }
            
            // 다음 버튼
            if (currentUserCumulativePage < totalPages) {
                pagination += `<button onclick="changeUserCumulativePage(${currentUserCumulativePage + 1})" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; margin: 0 2px;">›</button>`;
            }
            
            return pagination;
        }

        // Overview 활동리스트 페이지네이션 생성 (Members와 동일)
        function generateOverviewActivityPagination(totalPages) {
            let pagination = '';
            
            // 이전 버튼
            if (currentActivityPage > 1) {
                pagination += `<button onclick="changeOverviewActivityPage(${currentActivityPage - 1})" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; margin: 0 2px;">‹</button>`;
            }
            
            // 페이지 번호들
            let startPage = Math.max(1, currentActivityPage - 2);
            let endPage = Math.min(totalPages, currentActivityPage + 2);
            
            // 첫 페이지가 범위에 없으면 추가
            if (startPage > 1) {
                pagination += `<button onclick="changeOverviewActivityPage(1)" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; margin: 0 2px;">1</button>`;
                if (startPage > 2) {
                    pagination += `<span style="color: #7a7a7a; padding: 0 5px;">...</span>`;
                }
            }
            
            // 현재 범위의 페이지들
            for (let i = startPage; i <= endPage; i++) {
                const isActive = i === currentActivityPage;
                pagination += `<button onclick="changeOverviewActivityPage(${i})" style="background: ${isActive ? '#4a9eff' : '#3a3a3a'}; border: 1px solid ${isActive ? '#4a9eff' : '#4a4a4a'}; color: ${isActive ? 'white' : '#e1e1e1'}; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: ${isActive ? '600' : 'normal'}; margin: 0 2px;">${i}</button>`;
            }
            
            // 마지막 페이지가 범위에 없으면 추가
            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    pagination += `<span style="color: #7a7a7a; padding: 0 5px;">...</span>`;
                }
                pagination += `<button onclick="changeOverviewActivityPage(${totalPages})" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; margin: 0 2px;">${totalPages}</button>`;
            }
            
            // 다음 버튼
            if (currentActivityPage < totalPages) {
                pagination += `<button onclick="changeOverviewActivityPage(${currentActivityPage + 1})" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; margin: 0 2px;">›</button>`;
            }
            
            return pagination;
        }

        // Overview 활동리스트 페이지 변경
        function changeOverviewActivityPage(page) {
            currentActivityPage = page;
            renderOverviewActivityTableWithPagination(currentActivityData);
        }

        // Overview 활동리스트 페이지 크기 변경
        function changeOverviewActivityPageSize(pageSize) {
            currentActivityPageSize = parseInt(pageSize);
            currentActivityPage = 1; // 페이지 크기 변경시 첫 페이지로 이동
            renderOverviewActivityTableWithPagination(currentActivityData);
        }

        // Members 페이지네이션 생성 (All Raw Events와 동일)
        function generateMembersPagination(totalPages) {
            let pagination = '';
            
            // 이전 버튼
            if (currentMembersPage > 1) {
                pagination += `<button onclick="changeMembersPage(${currentMembersPage - 1})" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; margin: 0 2px;">‹</button>`;
            }
            
            // 페이지 번호들
            let startPage = Math.max(1, currentMembersPage - 2);
            let endPage = Math.min(totalPages, currentMembersPage + 2);
            
            // 첫 페이지가 범위에 없으면 추가
            if (startPage > 1) {
                pagination += `<button onclick="changeMembersPage(1)" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; margin: 0 2px;">1</button>`;
                if (startPage > 2) {
                    pagination += `<span style="color: #7a7a7a; padding: 0 5px;">...</span>`;
                }
            }
            
            // 현재 범위의 페이지들
            for (let i = startPage; i <= endPage; i++) {
                const isActive = i === currentMembersPage;
                pagination += `<button onclick="changeMembersPage(${i})" style="background: ${isActive ? '#4a9eff' : '#3a3a3a'}; border: 1px solid ${isActive ? '#4a9eff' : '#4a4a4a'}; color: ${isActive ? 'white' : '#e1e1e1'}; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: ${isActive ? '600' : 'normal'}; margin: 0 2px;">${i}</button>`;
            }
            
            // 마지막 페이지가 범위에 없으면 추가
            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    pagination += `<span style="color: #7a7a7a; padding: 0 5px;">...</span>`;
                }
                pagination += `<button onclick="changeMembersPage(${totalPages})" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; margin: 0 2px;">${totalPages}</button>`;
            }
            
            // 다음 버튼
            if (currentMembersPage < totalPages) {
                pagination += `<button onclick="changeMembersPage(${currentMembersPage + 1})" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; margin: 0 2px;">›</button>`;
            }
            
            return pagination;
        }

        // Members 페이지 변경
        function changeMembersPage(page) {
            currentMembersPage = page;
            renderMembersTableWithPagination(currentMembersData);
        }

        // Members 페이지 크기 변경
        function changeMembersPageSize(pageSize) {
            currentMembersPageSize = parseInt(pageSize);
            currentMembersPage = 1; // 페이지 크기 변경시 첫 페이지로 이동
            renderMembersTableWithPagination(currentMembersData);
        }

        // 검색창 X 버튼 표시/숨김 토글
        function toggleSearchClearBtn(searchId) {
            const searchInput = document.getElementById(searchId);
            const clearBtn = document.getElementById(searchId + '-clear');
            
            if (searchInput && clearBtn) {
                if (searchInput.value.length > 0) {
                    clearBtn.style.display = 'flex';
                } else {
                    clearBtn.style.display = 'none';
                }
            }
        }

        // 검색창 비우기
        function clearSearch(searchId) {
            const searchInput = document.getElementById(searchId);
            const clearBtn = document.getElementById(searchId + '-clear');
            const autocomplete = document.getElementById(searchId.replace('-search', '-autocomplete'));
            
            if (searchInput) {
                searchInput.value = '';
                clearBtn.style.display = 'none';
                
                // 자동완성 드롭다운 숨기기
                if (autocomplete) {
                    autocomplete.style.display = 'none';
                }
                
                // 검색 필터 초기화
                if (searchId === 'members-search') {
                    filterMembers('');
                } else if (searchId === 'usage-search') {
                    filterUsageMembers('');
                }
            }
        }

        // 자동완성 드롭다운 표시
        function showAutocomplete(searchId) {
            const searchInput = document.getElementById(searchId);
            const autocomplete = document.getElementById(searchId.replace('-search', '-autocomplete'));
            
            if (!searchInput || !autocomplete) return;
            
            const searchTerm = searchInput.value.toLowerCase().trim();
            
            if (searchTerm.length === 0) {
                autocomplete.style.display = 'none';
                return;
            }
            
            // 사용자 데이터 가져오기
            let users = [];
            if (searchId === 'members-search') {
                users = getMembersUsers();
            } else if (searchId === 'usage-search') {
                users = getUsageUsers();
            }
            
            // 검색어와 매칭되는 사용자 필터링
            const filteredUsers = users.filter(user => 
                user.name.toLowerCase().includes(searchTerm) || 
                user.email.toLowerCase().includes(searchTerm)
            );
            
            if (filteredUsers.length === 0) {
                autocomplete.style.display = 'none';
                return;
            }
            
            // 드롭다운 HTML 생성
            const dropdownHTML = filteredUsers.map(user => `
                <div class="autocomplete-item" onclick="selectUser('${searchId}', '${user.email}')">
                    <div class="user-name">${user.name}</div>
                    <div class="user-email">${user.email}</div>
                </div>
            `).join('');
            
            autocomplete.innerHTML = dropdownHTML;
            autocomplete.style.display = 'block';
        }

        // 사용자 선택
        function selectUser(searchId, userEmail) {
            const searchInput = document.getElementById(searchId);
            const autocomplete = document.getElementById(searchId.replace('-search', '-autocomplete'));
            
            if (searchInput) {
                searchInput.value = userEmail;
                
                // 검색 실행
                if (searchId === 'members-search') {
                    filterMembers(userEmail);
                } else if (searchId === 'usage-search') {
                    filterUsageMembers(userEmail);
                }
                
                // X 버튼 표시
                toggleSearchClearBtn(searchId);
            }
            
            // 드롭다운 숨기기
            if (autocomplete) {
                autocomplete.style.display = 'none';
            }
        }

        // Members 섹션 사용자 데이터 가져오기
        function getMembersUsers() {
            if (!currentMembersData || currentMembersData.length === 0) {
                return [];
            }
            
            return currentMembersData.map(member => ({
                name: member.name || 'Unnamed',
                email: member.email
            }));
        }

        // Usage 섹션 사용자 데이터 가져오기
        function getUsageUsers() {
            if (!currentUserCumulativeData || currentUserCumulativeData.length === 0) {
                return [];
            }
            
            return currentUserCumulativeData.map(user => ({
                name: user.name || 'Unnamed',
                email: user.email
            }));
        }

        // 멤버 검색 기능
        function filterMembers(searchTerm) {
            const rows = document.querySelectorAll('#members .table-row');
            const searchLower = searchTerm.toLowerCase();
           
            rows.forEach(row => {
                const name = row.children[0].textContent.toLowerCase();
                const email = row.children[1].textContent.toLowerCase();
               
                if (name.includes(searchLower) || email.includes(searchLower)) {
                    row.style.display = 'grid';
                } else {
                    row.style.display = 'none';
                }
            });
        }

        // Usage 섹션 현재 필터로 업데이트
        async function updateUsageWithCurrentFilter(days = 30, showLoading = true) {
            try {
                // 이미 로딩 중이면 중복 실행 방지
                if (isUsageLoading) {
                    console.log('⚠️ Usage 데이터 로딩 중 - 중복 실행 방지');
                    return;
                }
                
                console.log(`=== Usage 섹션 ${days}일 필터로 업데이트 시작 (로딩 표시: ${showLoading}) ===`);
                
                isUsageLoading = true;
                
                // 날짜 범위 계산
                const dateRange = getDateRange(days);
                currentUsageDateRange = null; // 사용자 정의 범위 초기화
                
                await updateUsageWithDateRange(dateRange.startDate, dateRange.endDate, showLoading);
                
                // 첫 번째 로딩 완료 표시
                if (showLoading) {
                    isUsageDataLoaded = true;
                }
                
                isUsageLoading = false;
                console.log(`=== Usage 섹션 ${days}일 필터 업데이트 완료 ===`);
            } catch (error) {
                console.error('❌ Usage 필터 업데이트 실패:', error);
                isUsageLoading = false;
            }
        }

        // Usage 섹션 특정 날짜 범위로 업데이트
        async function updateUsageWithDateRange(startDate, endDate, showLoading = true) {
            try {
                console.log(`=== Usage 섹션 날짜 범위 업데이트 시작: ${new Date(startDate).toLocaleDateString()} ~ ${new Date(endDate).toLocaleDateString()} (로딩 표시: ${showLoading}) ===`);
                
                // 로딩 상태 표시 (첫 번째 로딩에만)
                if (showLoading) {
                    showUsageLoadingState(true);
                }
                
                // API 데이터 가져오기
                const [membersData, eventsData, usageData, spendingData] = await Promise.all([
                    getTeamMembers(),
                    getFilteredEvents(startDate, endDate),
                    getUsageData(startDate, endDate),
                    getTeamSpendingData()
                ]);
                
                // Usage 카드 업데이트
                updateUsageCards(usageData, eventsData);
                
                // 사용자별 누적 사용량 정보 업데이트
                updateUserCumulativeInfo(membersData, eventsData, spendingData, startDate, endDate);
                
                // All Raw Events 업데이트 (페이지 초기화)
                currentRawEventsPage = 1;
                updateRawEventsTable(eventsData);
                
                // 로딩 상태 해제 (첫 번째 로딩에만)
                if (showLoading) {
                    showUsageLoadingState(false);
                }
                
                console.log(`=== Usage 섹션 날짜 범위 업데이트 완료 ===`);
            } catch (error) {
                console.error('❌ Usage 날짜 범위 업데이트 실패:', error);
                if (showLoading) {
                    showUsageLoadingState(false);
                }
            }
        }

        // Usage 로딩 상태 표시/해제
        function showUsageLoadingState(isLoading) {
            const usageCards = document.querySelectorAll('#usage .usage-card-number');
            const userTables = document.querySelectorAll('#usage .user-cumulative-info');
            
            if (isLoading) {
                usageCards.forEach(card => {
                    card.textContent = '-';
                });
                userTables.forEach(table => {
                    table.style.opacity = '0.5';
                });
            } else {
                userTables.forEach(table => {
                    table.style.opacity = '1';
                });
            }
        }

        // Usage 카드 업데이트 (Overview와 Usage 섹션 모두)
        function updateUsageCards(usageData, eventsData) {
            // Overview 섹션과 Usage 섹션 모두의 카드를 찾음
            const overviewCards = document.querySelectorAll('#overview .usage-card-number');
            const usageCards = document.querySelectorAll('#usage .usage-card-number');
            const allCards = [...overviewCards, ...usageCards];
            
            if (!usageData || !usageData.data) {
                allCards.forEach((card, index) => {
                    const cardIndex = index % 4; // 4개 카드 반복
                    card.textContent = '0';
                });
                console.log('📊 Usage 카드 업데이트: 데이터 없음 - 모든 값을 0으로 설정');
                return;
            }
            
            // 실제 활동한 사용자 수 계산
            const activeUsers = new Set();
            if (eventsData && eventsData.usageEvents) {
                eventsData.usageEvents.forEach(event => {
                    if (event.userEmail && event.requestsCosts > 0) {
                        activeUsers.add(event.userEmail);
                    }
                });
            }
            
            // 집계 계산
            let totalLinesAdded = 0;
            let totalLinesAccepted = 0;
            let totalTabsAccepted = 0;
            let totalChats = 0;
            
            usageData.data.forEach(dayData => {
                totalLinesAdded += (dayData.totalLinesAdded || 0);
                totalLinesAccepted += (dayData.acceptedLinesAdded || 0);
                totalTabsAccepted += (dayData.totalTabsAccepted || 0);
                totalChats += (dayData.chatRequests || 0);
            });
            
            // 카드 업데이트 (Overview와 Usage 섹션 모두)
            const values = [
                activeUsers.size.toLocaleString(), // Total Users
                (totalLinesAdded + totalLinesAccepted).toLocaleString(), // Lines of Agent Edits
                totalTabsAccepted.toLocaleString(), // Tabs Accepted
                totalChats.toLocaleString() // Chats
            ];
            
            allCards.forEach((card, index) => {
                const cardIndex = index % 4; // 4개 카드 반복
                card.textContent = values[cardIndex];
            });
            
            console.log(`Usage 카드 업데이트: 사용자 ${activeUsers.size}명, 라인 ${totalLinesAdded + totalLinesAccepted}줄, 탭 ${totalTabsAccepted}개, 채팅 ${totalChats}건`);
        }

        // 사용자별 누적 사용량 정보 테이블 렌더링 (All Raw Events 스타일)
        function renderUserCumulativeTableWithPagination(userInfos, startDate, endDate) {
            console.log('🎨 renderUserCumulativeTableWithPagination 함수 호출됨');
            console.log('📊 렌더링 데이터:', {
                userInfos: userInfos ? `${userInfos.length}명` : 'null',
                startDate: startDate,
                endDate: endDate
            });
            
            // 헤더 업데이트
            const headerElement = document.querySelector('.user-cumulative-info .user-cumulative-header');
            if (headerElement) {
                if (!userInfos || userInfos.length === 0) {
                    headerElement.innerHTML = '📊 사용자별 누적 사용량 정보';
                } else {
                    const totalUsers = userInfos.length;
                    const totalPages = Math.ceil(totalUsers / currentUserCumulativePageSize);
                    const startIndex = (currentUserCumulativePage - 1) * currentUserCumulativePageSize;
                    const endIndex = Math.min(startIndex + currentUserCumulativePageSize, totalUsers);
                    
                    // 날짜 형식 변경 (날짜 끝의 "." 제거)
                    const cleanStartDate = new Date(startDate).toLocaleDateString('ko-KR').replace(/\.$/, '');
                    const cleanEndDate = new Date(endDate).toLocaleDateString('ko-KR').replace(/\.$/, '');
                    
                    headerElement.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span>📊 사용자별 누적 사용량 정보 (${cleanStartDate} ~ ${cleanEndDate})(${startIndex + 1}-${endIndex} of ${totalUsers})</span>
                            <select id="userCumulativePageSize" onchange="changeUserCumulativePageSize(this.value)" style="background: #3a3a3a; color: #fff; border: 1px solid #4a4a4a; padding: 5px 10px; border-radius: 4px; font-size: 12px;">
                                <option value="10" ${currentUserCumulativePageSize === 10 ? 'selected' : ''}>10개 보기</option>
                                <option value="20" ${currentUserCumulativePageSize === 20 ? 'selected' : ''}>20개 보기</option>
                                <option value="30" ${currentUserCumulativePageSize === 30 ? 'selected' : ''}>30개 보기</option>
                                <option value="50" ${currentUserCumulativePageSize === 50 ? 'selected' : ''}>50개 보기</option>
                                <option value="100" ${currentUserCumulativePageSize === 100 ? 'selected' : ''}>100개 보기</option>
                            </select>
                        </div>
                    `;
                }
            }
            
            if (!userInfos || userInfos.length === 0) {
                const container = document.getElementById('user-cumulative-container');
                if (container) {
                    container.innerHTML = `
                        <div style="padding: 20px; text-align: center; color: #7a7a7a; background-color: #1a1a1a;">
                            사용자별 누적 사용량 데이터가 없습니다.
                        </div>
                    `;
                }
                // 페이지네이션 숨기기
                const pagination = document.getElementById('user-cumulative-pagination');
                if (pagination) pagination.style.display = 'none';
                return;
            }
            
            // 페이지네이션 계산
            const totalUsers = userInfos.length;
            const totalPages = Math.ceil(totalUsers / currentUserCumulativePageSize);
            const startIndex = (currentUserCumulativePage - 1) * currentUserCumulativePageSize;
            const endIndex = Math.min(startIndex + currentUserCumulativePageSize, totalUsers);
            const pageUsers = userInfos.slice(startIndex, endIndex);

            console.log(`📄 사용자별 누적 사용량 페이지네이션: ${startIndex + 1}-${endIndex} of ${totalUsers} (페이지 ${currentUserCumulativePage}/${totalPages})`);
            
            // 테이블 내용만 업데이트
            const tableContent = pageUsers.map(user => `
                <div class="user-cumulative-row">
                    <div>${user.name}</div>
                    <div class="user-email clickable-email" title="View usage for ${user.email}" onclick="navigateToUsageWithEmail('${user.email}')">${user.email}</div>
                    <div><span class="role-badge ${user.role === 'owner' ? 'admin' : ''}">${user.role === 'owner' ? 'Admin' : 'Member'}</span></div>
                    <div style="font-weight: 600;">${user.periodRequests}</div>
                    <div>$${user.spend.toFixed(2)}</div>
                    <div>${user.lastActivity}</div>
                </div>
            `).join('');
            
            // 컨테이너에 테이블 내용만 삽입
            const container = document.getElementById('user-cumulative-container');
            if (container) {
                container.innerHTML = tableContent;
            }

            // 페이지네이션 업데이트
            const paginationContainer = document.getElementById('user-cumulative-pagination');
            if (paginationContainer && totalPages > 1) {
                paginationContainer.innerHTML = generateUserCumulativePagination(totalPages);
                paginationContainer.style.display = 'block';
            } else if (paginationContainer) {
                paginationContainer.style.display = 'none';
            }
            
            console.log('✅ 사용자별 누적 사용량 정보 테이블 HTML 렌더링 완료');
            console.log(`📊 사용자별 누적 사용량 정보 업데이트: 총 ${userInfos.length}명 (페이지 ${currentUserCumulativePage}/${totalPages})`);
        }
        

        
        // 사용자별 누적 사용량 정보 페이지 변경 (All Raw Events 스타일)
        function changeUserCumulativePage(page) {
            currentUserCumulativePage = page;
            renderUserCumulativeTableWithPagination(currentUserCumulativeData, currentUserCumulativeStartDate, currentUserCumulativeEndDate);
        }
        
        // 사용자별 누적 사용량 정보 페이지 크기 변경 (All Raw Events 스타일)
        function changeUserCumulativePageSize(pageSize) {
            currentUserCumulativePageSize = parseInt(pageSize);
            currentUserCumulativePage = 1; // 페이지 크기 변경시 첫 페이지로 이동
            renderUserCumulativeTableWithPagination(currentUserCumulativeData, currentUserCumulativeStartDate, currentUserCumulativeEndDate);
        }

        // 사용자별 누적 사용량 정보 업데이트
        function updateUserCumulativeInfo(membersData, eventsData, spendingData, startDate, endDate) {
            console.log('🔍 updateUserCumulativeInfo 함수 호출됨');
            console.log('📊 전달받은 데이터:', {
                membersData: membersData ? `${membersData.teamMembers?.length || 0}명` : 'null',
                eventsData: eventsData ? `${eventsData.usageEvents?.length || 0}개 이벤트` : 'null',
                spendingData: spendingData ? `${spendingData.teamMemberSpend?.length || 0}개 지출` : 'null',
                startDate: startDate,
                endDate: endDate
            });
            
            if (!membersData || !membersData.teamMembers) {
                console.log('⚠️ 사용자별 누적 사용량 정보: 멤버 데이터가 없습니다.');
                console.log('상세 정보:', {
                    membersData: !!membersData,
                    teamMembers: membersData?.teamMembers?.length || 0
                });
                return;
            }
            
            console.log('=== 사용자별 누적 사용량 정보 업데이트 시작 ===');
            
            // 지출 데이터 매핑
            const memberSpendMap = {};
            if (spendingData && spendingData.teamMemberSpend) {
                spendingData.teamMemberSpend.forEach(spendInfo => {
                    memberSpendMap[spendInfo.email] = {
                        premiumRequests: spendInfo.fastPremiumRequests || 0,
                        spend: (spendInfo.spendCents || 0) / 100,
                        hardLimitOverride: spendInfo.hardLimitOverrideDollars || 0
                    };
                });
            }
            
            // 선택된 기간 내 사용자별 활동 통계 계산
            const userPeriodStats = {};
            if (eventsData && eventsData.usageEvents) {
                eventsData.usageEvents.forEach(event => {
                    const userEmail = event.userEmail;
                    const timestamp = parseInt(event.timestamp);
                    
                    if (!userPeriodStats[userEmail]) {
                        userPeriodStats[userEmail] = {
                            lastTimestamp: timestamp,
                            periodRequests: 0
                        };
                    }
                    
                    // 마지막 활동 시간 업데이트
                    if (timestamp > userPeriodStats[userEmail].lastTimestamp) {
                        userPeriodStats[userEmail].lastTimestamp = timestamp;
                    }
                    
                    // 선택된 기간 내 요청 비용 누적 (All Raw Events의 COST값과 동일)
                    const requestCost = event.requestsCosts || 0;
                    userPeriodStats[userEmail].periodRequests += requestCost;
                    
                    // 디버깅을 위한 로그 (처음 5개 이벤트만)
                    if (Object.keys(userPeriodStats).length <= 5 && userPeriodStats[userEmail].periodRequests <= requestCost * 3) {
                        console.log(`💰 ${userEmail}: +${requestCost} (누적: ${userPeriodStats[userEmail].periodRequests})`);
                    }
                });
            }
            
            // 사용자 정보 생성
            const userInfos = membersData.teamMembers.map(member => {
                const spendData = memberSpendMap[member.email] || {};
                const periodStats = userPeriodStats[member.email] || {};
                const actualSpend = spendData.spend || 0;
                const totalPremiumRequests = spendData.premiumRequests || 0; // 전체 기간 Premium Requests
                const periodRequests = periodStats.periodRequests || 0; // 선택된 기간 내 요청 수
                
                // 마지막 활동 날짜 계산
                let lastActivityText = 'No Activity';
                if (periodStats.lastTimestamp) {
                    const lastDate = new Date(periodStats.lastTimestamp);
                    const today = new Date();
                    const daysDiff = Math.floor((today - lastDate) / (1000 * 60 * 60 * 24));
                    
                    if (daysDiff === 0) {
                        lastActivityText = '오늘';
                    } else if (daysDiff === 1) {
                        lastActivityText = '어제';
                    } else {
                        lastActivityText = `${daysDiff}일 전`;
                    }
                }
                
                return {
                    name: member.name || 'Unnamed',
                    email: member.email,
                    role: member.role,
                    totalPremiumRequests: totalPremiumRequests, // 전체 Premium Requests
                    periodRequests: periodRequests, // 선택된 기간 내 요청 수
                    spend: actualSpend,
                    lastActivity: lastActivityText,
                    lastTimestamp: periodStats.lastTimestamp || 0
                };
            });
            
            // 1. Last Act 최신순, 2. Request 기준 내림차순으로 정렬
            userInfos.sort((a, b) => {
                // 1차 정렬: Last Act (마지막 활동) 최신순 - timestamp 기준 내림차순
                if (b.lastTimestamp !== a.lastTimestamp) {
                    return b.lastTimestamp - a.lastTimestamp;
                }
                // 2차 정렬: Request 기준 내림차순
                return b.periodRequests - a.periodRequests;
            });
            
            // 데이터 저장 및 페이지네이션 적용
            currentUserCumulativeData = userInfos;
            currentUserCumulativeStartDate = startDate;
            currentUserCumulativeEndDate = endDate;
            currentUserCumulativePage = 1; // 첫 페이지로 리셋
            
            // 페이지네이션 적용
            renderUserCumulativeTableWithPagination(userInfos, startDate, endDate);
            
            console.log(`사용자별 누적 사용량 정보 업데이트 완료: ${userInfos.length}명`);
            console.log(`선택된 기간 내 총 요청 수: ${userInfos.reduce((sum, user) => sum + user.periodRequests, 0)}건`);
        }

        // All Raw Events 테이블 업데이트
        function updateRawEventsTable(eventsData) {
            const tableContainer = document.querySelector('#usage .user-cumulative-info:last-child');
            if (!tableContainer || !eventsData || !eventsData.usageEvents) return;
            
            // 검색 중인 경우 자동 업데이트 방지
            if (window.pendingEmailSearch) {
                console.log(`⏳ 이메일 검색 대기 중 (${window.pendingEmailSearch}) - Raw Events 테이블 자동 업데이트 건너뜀`);
                // 데이터는 저장하되 테이블 렌더링은 하지 않음
                currentRawEventsData = eventsData.usageEvents.sort((a, b) => {
                    const timestampA = parseInt(a.timestamp) || 0;
                    const timestampB = parseInt(b.timestamp) || 0;
                    return timestampB - timestampA; // 내림차순 (최신 → 과거)
                });
                return;
            }
            
            // 전체 데이터 저장 및 DATE 기준 내림차순 정렬 (최신순)
            currentRawEventsData = eventsData.usageEvents.sort((a, b) => {
                const timestampA = parseInt(a.timestamp) || 0;
                const timestampB = parseInt(b.timestamp) || 0;
                return timestampB - timestampA; // 내림차순 (최신 → 과거)
            });
            
            // 페이지네이션 적용
            renderRawEventsTableWithPagination();
        }

        // Raw Events 테이블 페이지네이션과 함께 렌더링
        function renderRawEventsTableWithPagination() {
            const tableContainer = document.querySelector('#usage .user-cumulative-info:last-child');
            if (!tableContainer || !currentRawEventsData.length) return;
            
            const totalEvents = currentRawEventsData.length;
            const totalPages = Math.ceil(totalEvents / currentRawEventsPageSize);
            const startIndex = (currentRawEventsPage - 1) * currentRawEventsPageSize;
            const endIndex = Math.min(startIndex + currentRawEventsPageSize, totalEvents);
            const pageEvents = currentRawEventsData.slice(startIndex, endIndex);
            
            const tableHtml = `
                <div class="user-cumulative-header" style="display: flex; justify-content: space-between; align-items: center;">
                    <span>📋 All Raw Events (${startIndex + 1}-${endIndex} of ${totalEvents})</span>
                    <select id="rawEventsPageSize" onchange="changeRawEventsPageSize(this.value)" style="background: #3a3a3a; color: #fff; border: 1px solid #4a4a4a; padding: 5px 10px; border-radius: 4px; font-size: 12px;">
                        <option value="10" ${currentRawEventsPageSize === 10 ? 'selected' : ''}>10개 보기</option>
                        <option value="20" ${currentRawEventsPageSize === 20 ? 'selected' : ''}>20개 보기</option>
                        <option value="30" ${currentRawEventsPageSize === 30 ? 'selected' : ''}>30개 보기</option>
                        <option value="50" ${currentRawEventsPageSize === 50 ? 'selected' : ''}>50개 보기</option>
                        <option value="100" ${currentRawEventsPageSize === 100 ? 'selected' : ''}>100개 보기</option>
                    </select>
                </div>
                <div class="user-cumulative-table">
                    <div>DATE</div>
                    <div>USER</div>
                    <div>KIND</div>
                    <div>MAX_MODEL</div>
                    <div>MODEL</div>
                    <div>TOKENS</div>
                    <div>COST</div>
                </div>
                ${pageEvents.map(event => {
                    const date = new Date(parseInt(event.timestamp));
                    const dateText = date.toLocaleDateString('en-US', { 
                        month: 'short', 
                        day: 'numeric', 
                        hour: '2-digit', 
                        minute: '2-digit' 
                    });
                    
                    // 토큰 정보 계산
                    let tokensText = 'N/A';
                    if (event.tokenUsage) {
                        const inputTokens = event.tokenUsage.inputTokens || 0;
                        const outputTokens = event.tokenUsage.outputTokens || 0;
                        const totalTokens = inputTokens + outputTokens;
                        tokensText = totalTokens.toLocaleString();
                    }
                    
                    return `
                        <div class="user-cumulative-row">
                            <div>${dateText}</div>
                            <div class="user-email">${event.userEmail}</div>
                            <div>${(event.kindLabel || 'Unknown').substring(0, 15)}${(event.kindLabel || '').length > 15 ? '...' : ''}</div>
                            <div>${event.maxMode ? 'Yes' : 'No'}</div>
                            <div>${(event.model || 'auto').substring(0, 10)}${(event.model || '').length > 10 ? '...' : ''}</div>
                            <div>${tokensText}</div>
                            <div>${event.requestsCosts || 0}</div>
                        </div>
                    `;
                }).join('')}
                ${totalPages > 1 ? `
                    <div style="padding: 15px 20px; background-color: #2a2a2a; border-top: 1px solid #3a3a3a; display: flex; justify-content: center; align-items: center; gap: 10px;">
                        ${generateRawEventsPagination(totalPages)}
                    </div>
                ` : ''}
            `;
            
            tableContainer.innerHTML = tableHtml;
            
            console.log(`Raw Events 테이블 업데이트 완료: 페이지 ${currentRawEventsPage}/${totalPages}, ${pageEvents.length}개 이벤트 표시`);
        }

        // Raw Events 페이지네이션 생성
        function generateRawEventsPagination(totalPages) {
            let pagination = '';
            
            // 이전 버튼
            if (currentRawEventsPage > 1) {
                pagination += `<button onclick="changeRawEventsPage(${currentRawEventsPage - 1})" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">‹</button>`;
            }
            
            // 페이지 번호들
            let startPage = Math.max(1, currentRawEventsPage - 2);
            let endPage = Math.min(totalPages, currentRawEventsPage + 2);
            
            // 첫 페이지가 범위에 없으면 추가
            if (startPage > 1) {
                pagination += `<button onclick="changeRawEventsPage(1)" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">1</button>`;
                if (startPage > 2) {
                    pagination += `<span style="color: #7a7a7a; padding: 0 5px;">...</span>`;
                }
            }
            
            // 현재 범위의 페이지들
            for (let i = startPage; i <= endPage; i++) {
                const isActive = i === currentRawEventsPage;
                pagination += `<button onclick="changeRawEventsPage(${i})" style="background: ${isActive ? '#4a9eff' : '#3a3a3a'}; border: 1px solid ${isActive ? '#4a9eff' : '#4a4a4a'}; color: ${isActive ? 'white' : '#e1e1e1'}; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: ${isActive ? '600' : 'normal'};">${i}</button>`;
            }
            
            // 마지막 페이지가 범위에 없으면 추가
            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    pagination += `<span style="color: #7a7a7a; padding: 0 5px;">...</span>`;
                }
                pagination += `<button onclick="changeRawEventsPage(${totalPages})" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">${totalPages}</button>`;
            }
            
            // 다음 버튼
            if (currentRawEventsPage < totalPages) {
                pagination += `<button onclick="changeRawEventsPage(${currentRawEventsPage + 1})" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">›</button>`;
            }
            
            return pagination;
        }

        // Raw Events 페이지 변경
        function changeRawEventsPage(page) {
            currentRawEventsPage = page;
            renderRawEventsTableWithPagination();
        }

        // Raw Events 페이지 크기 변경
        function changeRawEventsPageSize(pageSize) {
            currentRawEventsPageSize = parseInt(pageSize);
            currentRawEventsPage = 1; // 페이지 크기 변경시 첫 페이지로 이동
            renderRawEventsTableWithPagination();
        }

        // 필터링된 Raw Events 테이블 렌더링 (페이지네이션 포함)
        function renderFilteredRawEventsTable(filteredEvents, container) {
            if (!container || !filteredEvents) return;
            
            // 페이지네이션 설정 - 기존 설정이 있으면 사용, 없으면 기본값
            const pageSize = window.currentFilteredEventsPageSize || 20;
            const currentPage = window.currentFilteredEventsPage || 1;
            const totalPages = Math.ceil(filteredEvents.length / pageSize);
            
            // 현재 페이지의 이벤트만 추출
            const startIndex = (currentPage - 1) * pageSize;
            const endIndex = Math.min(startIndex + pageSize, filteredEvents.length);
            const pageEvents = filteredEvents.slice(startIndex, endIndex);
            
            console.log(`📄 필터링된 Raw Events 페이지네이션: ${startIndex + 1}-${endIndex} of ${filteredEvents.length} (페이지 ${currentPage}/${totalPages})`);
            
            // 일반 테이블과 동일한 구조로 HTML 생성 (페이지네이션 포함)
            const tableHtml = `
                <div class="user-cumulative-header" style="display: flex; justify-content: space-between; align-items: center;">
                    <span>📋 All Raw Events - 검색 결과 (${startIndex + 1}-${endIndex} of ${filteredEvents.length})</span>
                    <select onchange="changeFilteredEventsPageSize(this.value)" style="background: #3a3a3a; color: #fff; border: 1px solid #4a4a4a; padding: 5px 10px; border-radius: 4px; font-size: 12px;">
                        <option value="10" ${pageSize === 10 ? 'selected' : ''}>10개 보기</option>
                        <option value="20" ${pageSize === 20 ? 'selected' : ''}>20개 보기</option>
                        <option value="30" ${pageSize === 30 ? 'selected' : ''}>30개 보기</option>
                        <option value="50" ${pageSize === 50 ? 'selected' : ''}>50개 보기</option>
                        <option value="100" ${pageSize === 100 ? 'selected' : ''}>100개 보기</option>
                    </select>
                </div>
                <div class="user-cumulative-table">
                    <div>DATE</div>
                    <div>USER</div>
                    <div>KIND</div>
                    <div>MAX_MODEL</div>
                    <div>MODEL</div>
                    <div>TOKENS</div>
                    <div>COST</div>
                </div>
                ${pageEvents.map(event => {
                    const date = new Date(parseInt(event.timestamp));
                    const dateText = date.toLocaleDateString('en-US', { 
                        month: 'short', 
                        day: 'numeric', 
                        hour: '2-digit', 
                        minute: '2-digit' 
                    });
                    
                    // 토큰 정보 계산
                    let tokensText = 'N/A';
                    if (event.tokenUsage) {
                        const inputTokens = event.tokenUsage.inputTokens || 0;
                        const outputTokens = event.tokenUsage.outputTokens || 0;
                        const totalTokens = inputTokens + outputTokens;
                        tokensText = totalTokens.toLocaleString();
                    }
                    
                    return `
                        <div class="user-cumulative-row">
                            <div>${dateText}</div>
                            <div class="user-email">${event.userEmail}</div>
                            <div>${(event.kindLabel || 'Unknown').substring(0, 15)}${(event.kindLabel || '').length > 15 ? '...' : ''}</div>
                            <div>${event.maxMode ? 'Yes' : 'No'}</div>
                            <div>${(event.model || 'auto').substring(0, 10)}${(event.model || '').length > 10 ? '...' : ''}</div>
                            <div>${tokensText}</div>
                            <div>${event.requestsCosts || 0}</div>
                        </div>
                    `;
                }).join('')}
                ${totalPages > 1 ? `
                    <div style="padding: 15px 20px; background-color: #2a2a2a; border-top: 1px solid #3a3a3a; display: flex; justify-content: center; align-items: center; gap: 10px;">
                        ${generateFilteredEventsPagination(totalPages, currentPage)}
                    </div>
                ` : ''}
            `;
            
            container.innerHTML = tableHtml;
            
            // 필터링된 이벤트 데이터 저장 (페이지네이션용)
            window.currentFilteredEvents = filteredEvents;
            window.currentFilteredEventsPage = currentPage;
            window.currentFilteredEventsPageSize = pageSize;
            
            console.log(`필터링된 Raw Events 테이블 렌더링 완료: ${filteredEvents.length}개 이벤트 (페이지 ${currentPage}/${totalPages}, 페이지당 ${pageSize}개)`);
        }

        // 빈 Raw Events 테이블 렌더링
        function renderEmptyRawEventsTable(container, searchedEmails) {
            if (!container) return;
            
            const emailList = searchedEmails.join(', ');
            
            const tableHtml = `
                <div class="user-cumulative-header">
                    <span>📋 All Raw Events - 검색 결과 (0개)</span>
                </div>
                <div class="user-cumulative-table">
                    <div>DATE</div>
                    <div>USER</div>
                    <div>KIND</div>
                    <div>MAX_MODEL</div>
                    <div>MODEL</div>
                    <div>TOKENS</div>
                    <div>COST</div>
                </div>
                <div style="padding: 40px 20px; text-align: center; color: #7a7a7a; background-color: #1a1a1a; grid-column: 1 / -1;">
                    <h3 style="color: #e1e1e1; margin-bottom: 10px;">검색된 사용자의 활동이 없습니다</h3>
                    <p style="margin-bottom: 15px;">검색 대상: <strong style="color: #4a9eff;">${emailList}</strong></p>
                    <p style="font-size: 14px; line-height: 1.4;">
                        • 해당 사용자가 선택된 기간에 활동하지 않았을 수 있습니다<br>
                        • 다른 날짜 범위를 선택해보세요<br>
                        • 또는 다른 사용자를 검색해보세요
                    </p>
                </div>
            `;
            
            container.innerHTML = tableHtml;
            console.log(`빈 Raw Events 테이블 렌더링 완료 (검색 대상: ${emailList})`);
        }

        // 필터링된 이벤트 페이지네이션 생성 (일반 테이블과 동일한 구조)
        function generateFilteredEventsPagination(totalPages, currentPage) {
            let pagination = '';
            
            // 이전 페이지 버튼
            if (currentPage > 1) {
                pagination += `<button onclick="changeFilteredEventsPage(${currentPage - 1})" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">‹</button>`;
            }
            
            // 페이지 번호 버튼들
            let startPage = Math.max(1, currentPage - 2);
            let endPage = Math.min(totalPages, currentPage + 2);
            
            // 시작 페이지가 1이 아니면 첫 페이지 버튼 추가
            if (startPage > 1) {
                pagination += `<button onclick="changeFilteredEventsPage(1)" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">1</button>`;
                if (startPage > 2) {
                    pagination += `<span style="color: #7a7a7a; padding: 0 5px;">...</span>`;
                }
            }
            
            // 페이지 번호들
            for (let i = startPage; i <= endPage; i++) {
                const isActive = i === currentPage;
                pagination += `<button onclick="changeFilteredEventsPage(${i})" style="background: ${isActive ? '#4a9eff' : '#3a3a3a'}; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">${i}</button>`;
            }
            
            // 끝 페이지가 totalPages가 아니면 마지막 페이지 버튼 추가
            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    pagination += `<span style="color: #7a7a7a; padding: 0 5px;">...</span>`;
                }
                pagination += `<button onclick="changeFilteredEventsPage(${totalPages})" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">${totalPages}</button>`;
            }
            
            // 다음 페이지 버튼
            if (currentPage < totalPages) {
                pagination += `<button onclick="changeFilteredEventsPage(${currentPage + 1})" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">›</button>`;
            }
            
            return pagination;
        }

        // 필터링된 이벤트 페이지 변경
        function changeFilteredEventsPage(page) {
            if (!window.currentFilteredEvents) {
                console.log('⚠️ 필터링된 이벤트 데이터가 없습니다.');
                return;
            }
            
            window.currentFilteredEventsPage = page;
            const filteredEvents = window.currentFilteredEvents;
            const container = document.querySelector('#usage .user-cumulative-info:last-child');
            
            console.log(`📄 필터링된 Raw Events 페이지 변경: 페이지 ${page}로 이동`);
            console.log(`📄 컨테이너 발견: ${!!container}, 필터링된 이벤트 수: ${filteredEvents.length}`);
            
            if (container) {
                // renderFilteredRawEventsTable 함수를 재사용
                renderFilteredRawEventsTable(filteredEvents, container);
            } else {
                console.error('❌ Raw Events 컨테이너를 찾을 수 없습니다.');
            }
        }

        // 필터링된 이벤트 페이지 크기 변경
        function changeFilteredEventsPageSize(newPageSize) {
            console.log(`🔧 changeFilteredEventsPageSize 호출됨: ${newPageSize}`);
            console.log(`📊 현재 상태: currentFilteredEvents=${!!window.currentFilteredEvents}, currentFilteredEventsPage=${window.currentFilteredEventsPage}, currentFilteredEventsPageSize=${window.currentFilteredEventsPageSize}`);
            
            if (!window.currentFilteredEvents) {
                console.log('⚠️ 필터링된 이벤트 데이터가 없습니다.');
                return;
            }
            
            window.currentFilteredEventsPageSize = parseInt(newPageSize);
            window.currentFilteredEventsPage = 1; // 페이지 크기 변경시 첫 페이지로 이동
            
            const filteredEvents = window.currentFilteredEvents;
            const container = document.querySelector('#usage .user-cumulative-info:last-child');
            
            console.log(`📄 필터링된 Raw Events 페이지 크기 변경: ${newPageSize}개로 변경, 첫 페이지로 이동`);
            console.log(`📄 컨테이너 발견: ${!!container}, 필터링된 이벤트 수: ${filteredEvents.length}`);
            
            if (container) {
                // renderFilteredRawEventsTable 함수를 재사용
                renderFilteredRawEventsTable(filteredEvents, container);
            } else {
                console.error('❌ Raw Events 컨테이너를 찾을 수 없습니다.');
            }
        }
        
        // 디버깅용 전역 함수
        window.debugFilteredEvents = function() {
            console.log('=== 필터링된 이벤트 상태 디버깅 ===');
            console.log('currentFilteredEvents:', window.currentFilteredEvents ? window.currentFilteredEvents.length + '개' : 'null');
            console.log('currentFilteredEventsPage:', window.currentFilteredEventsPage);
            console.log('currentFilteredEventsPageSize:', window.currentFilteredEventsPageSize);
            console.log('컨테이너:', document.querySelector('#usage .user-cumulative-info:last-child'));
            console.log('==============================');
        };



        // Usage 멤버 검색 기능 (사용자별 누적 사용량 정보와 All Raw Events 테이블 연동)
        function filterUsageMembers(searchTerm) {
            const searchLower = searchTerm.toLowerCase().trim();
            
            console.log(`🔍 Usage 멤버 검색 시작: "${searchTerm}"`);
            
            // 검색어가 비어있으면 모든 행 표시
            if (searchLower === '') {
                const allRows = document.querySelectorAll('#usage .user-cumulative-row');
                allRows.forEach(row => {
                    row.style.display = 'grid';
                });
                
                // 전체 이벤트 로그 테이블도 함께 갱신
                if (currentRawEventsData && currentRawEventsData.length > 0) {
                    // 필터링된 이벤트 변수들 정리
                    delete window.currentFilteredEvents;
                    delete window.currentFilteredEventsPage;
                    delete window.currentFilteredEventsPageSize;
                    
                    renderRawEventsTableWithPagination();
                    console.log('✅ 검색어 없음 - 전체 Raw Events 페이지네이션 복원');
                }
                
                console.log('✅ 검색어 없음 - 모든 행 표시 및 전체 이벤트 로그 갱신');
                return;
            }
            
            // 이메일 주소인지 확인 (@ 포함 여부로 판단)
            const isEmailSearch = searchLower.includes('@');
            
            // 모든 Usage 섹션의 user-cumulative-info 컨테이너 가져오기
            const userInfoContainers = document.querySelectorAll('#usage .user-cumulative-info');
            
            if (userInfoContainers.length === 0) {
                console.log('⚠️ Usage 섹션의 user-cumulative-info 컨테이너를 찾을 수 없습니다.');
                return;
            }
            
            console.log(`📋 발견된 테이블 컨테이너: ${userInfoContainers.length}개`);
            
            // 사용자별 누적 사용량 정보 테이블 (첫 번째 컨테이너)과 All Raw Events 테이블 (두 번째 컨테이너) 구분
            const userCumulativeContainer = userInfoContainers[0]; // 첫 번째: 사용자별 누적 사용량 정보
            const rawEventsContainer = userInfoContainers[1]; // 두 번째: All Raw Events
            
            // 1. 사용자별 누적 사용량 정보 테이블에서 필터링하고 매칭된 이메일 수집
            const matchedEmails = new Set();
            
            // 정확한 이메일 매칭이 있는지 먼저 확인
            let hasExactMatch = false;
            if (isEmailSearch) {
                const allEmailElements = userCumulativeContainer.querySelectorAll('.user-cumulative-row .user-email, .user-cumulative-row div:nth-child(2)');
                hasExactMatch = Array.from(allEmailElements).some(element => 
                    element.textContent.toLowerCase().trim() === searchLower
                );
                console.log(`🔍 정확한 이메일 매칭 확인: ${hasExactMatch ? '발견됨' : '없음'}`);
            }
            
            // 사용자별 누적 사용량 정보 테이블 필터링
            const userCumulativeRows = userCumulativeContainer.querySelectorAll('.user-cumulative-row');
            console.log(`📊 사용자별 누적 사용량 정보: ${userCumulativeRows.length}개 행 발견`);
            
            userCumulativeRows.forEach(row => {
                if (row.children.length < 2) return; // 충분한 컬럼이 없으면 스킵
                
                const name = row.children[0].textContent.toLowerCase().trim();
                const email = row.children[1].textContent.toLowerCase().trim();
                
                let shouldShow = false;
                
                if (isEmailSearch) {
                    if (hasExactMatch) {
                        // 정확한 매칭이 있으면 정확한 매칭만 표시
                        shouldShow = email === searchLower;
                    } else {
                        // 정확한 매칭이 없으면 부분 매칭 허용
                        shouldShow = email.includes(searchLower);
                    }
                } else {
                    // 일반 검색: 이름 또는 이메일 부분 매칭
                    shouldShow = name.includes(searchLower) || email.includes(searchLower);
                }
                
                if (shouldShow) {
                    row.style.display = 'grid';
                    // 매칭된 이메일을 수집 (원본 이메일 저장)
                    const originalEmail = row.children[1].textContent.trim();
                    matchedEmails.add(originalEmail);
                } else {
                    row.style.display = 'none';
                }
            });
            
            console.log(`📧 매칭된 이메일: ${Array.from(matchedEmails).join(', ')}`);
            
            // 2. All Raw Events 테이블 연동 필터링 (전체 데이터에서 검색)
            if (rawEventsContainer && currentRawEventsData && currentRawEventsData.length > 0) {
                console.log(`📋 All Raw Events 전체 데이터: ${currentRawEventsData.length}개 이벤트`);
                console.log(`🔍 매칭 대상 이메일: ${Array.from(matchedEmails).join(', ')}`);
                
                // 검색어가 있으면 매칭된 이메일의 이벤트만 필터링
                if (matchedEmails.size > 0) {
                    // 새로운 검색 시작 시 페이지네이션 변수 초기화
                    window.currentFilteredEventsPage = 1;
                    window.currentFilteredEventsPageSize = window.currentFilteredEventsPageSize || 20;
                    
                    const filteredEvents = currentRawEventsData.filter(event => {
                        const eventUserEmail = event.userEmail?.trim() || '';
                        
                        // 정확한 이메일 매칭만 수행 (대소문자 무시)
                        return Array.from(matchedEmails).some(email => {
                            const emailLower = email.toLowerCase().trim();
                            const eventEmailLower = eventUserEmail.toLowerCase().trim();
                            return emailLower === eventEmailLower;
                        });
                    });
                    
                    console.log(`✅ 필터링된 Raw Events: ${filteredEvents.length}개`);
                    
                    if (filteredEvents.length > 0) {
                        // 필터링된 데이터로 테이블 다시 렌더링
                        renderFilteredRawEventsTable(filteredEvents, rawEventsContainer);
                        console.log(`✅ ${filteredEvents.length}개의 매칭된 이벤트를 표시했습니다.`);
                        console.log(`📊 전역 변수 상태: currentFilteredEvents=${!!window.currentFilteredEvents}, currentFilteredEventsPage=${window.currentFilteredEventsPage}, currentFilteredEventsPageSize=${window.currentFilteredEventsPageSize}`);
                    } else {
                        // 매칭된 이벤트가 없으면 빈 테이블 표시
                        renderEmptyRawEventsTable(rawEventsContainer, Array.from(matchedEmails));
                        console.log('⚠️ 매칭된 사용자의 Raw Events가 없습니다.');
                        console.log('💡 해당 사용자가 선택된 기간에 활동하지 않았을 수 있습니다.');
                    }
                } else {
                    // 검색어가 없으면 원래 페이지네이션 방식으로 복원
                    renderRawEventsTableWithPagination();
                    console.log('✅ 검색어 없음 - 전체 Raw Events 페이지네이션 복원');
                }
            } else {
                console.log('⚠️ All Raw Events 컨테이너 또는 데이터를 찾을 수 없습니다.');
                console.log(`   - 컨테이너 존재: ${!!rawEventsContainer}`);
                console.log(`   - 데이터 존재: ${!!currentRawEventsData}`);
                console.log(`   - 데이터 길이: ${currentRawEventsData?.length || 0}`);
            }
            
            const matchingType = isEmailSearch ? (hasExactMatch ? '정확한 이메일 매칭' : '이메일 부분 매칭') : '부분 매칭';
            console.log(`✅ Usage 검색 완료: "${searchTerm}" - ${matchingType}으로 두 테이블 연동 필터링 완료 (매칭된 사용자 ${matchedEmails.size}명)`);
            
            // 검색 완료 후 대기 중인 이메일 검색 플래그 제거
            if (window.pendingEmailSearch) {
                console.log(`🔄 이메일 검색 플래그 제거: ${window.pendingEmailSearch}`);
                delete window.pendingEmailSearch;
            }
        }

        // 멤버 정렬 기능
        let currentSortField = 'requests';
        let currentSortDirection = 'desc';

        function sortMembers(field) {
            const dataTable = document.querySelector('#members .data-table');
            const rows = Array.from(dataTable.querySelectorAll('.table-row'));
           
            // 정렬 방향 토글
            if (currentSortField === field) {
                currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                currentSortField = field;
                currentSortDirection = 'asc';
            }
           
            // 정렬 함수
            rows.sort((a, b) => {
                let aValue, bValue;
               
                switch(field) {
                    case 'name':
                        aValue = a.children[0].textContent.toLowerCase();
                        bValue = b.children[0].textContent.toLowerCase();
                        break;
                    case 'email':
                        aValue = a.children[1].textContent.toLowerCase();
                        bValue = b.children[1].textContent.toLowerCase();
                        break;
                    case 'requests':
                        aValue = parseInt(a.children[2].textContent.replace(/,/g, '')) || 0;
                        bValue = parseInt(b.children[2].textContent.replace(/,/g, '')) || 0;
                        break;
                    case 'spend':
                        aValue = parseFloat(a.children[3].textContent.replace('$', '')) || 0;
                        bValue = parseFloat(b.children[3].textContent.replace('$', '')) || 0;
                        break;
                    case 'role':
                        aValue = a.children[4].textContent.toLowerCase();
                        bValue = b.children[4].textContent.toLowerCase();
                        break;
                    default:
                        return 0;
                }
               
                if (currentSortDirection === 'asc') {
                    return aValue > bValue ? 1 : -1;
                } else {
                    return aValue < bValue ? 1 : -1;
                }
            });
           
            // 정렬된 행들을 다시 추가
            rows.forEach(row => dataTable.appendChild(row));
           
            // 헤더 업데이트
            updateSortHeaders(field);
        }

        // 정렬 헤더 업데이트
        function updateSortHeaders(field) {
            const headers = document.querySelectorAll('#members .table-header > div');
            headers.forEach((header, index) => {
                if (index < 5) { // 마지막 빈 열 제외
                    const text = header.textContent.replace(/[↑↓]/, '');
                    if (index === 0 && field === 'name') header.textContent = text + (currentSortDirection === 'asc' ? ' ↑' : ' ↓');
                    else if (index === 1 && field === 'email') header.textContent = text + (currentSortDirection === 'asc' ? ' ↑' : ' ↓');
                    else if (index === 2 && field === 'requests') header.textContent = text + (currentSortDirection === 'asc' ? ' ↑' : ' ↓');
                    else if (index === 3 && field === 'spend') header.textContent = text + (currentSortDirection === 'asc' ? ' ↑' : ' ↓');
                    else if (index === 4 && field === 'role') header.textContent = text + (currentSortDirection === 'asc' ? ' ↑' : ' ↓');
                    else header.textContent = text + ' ↕';
                }
            });
        }

        // 검색창 외부 클릭 시 자동완성 드롭다운 숨기기
        document.addEventListener('click', function(e) {
            const autocompleteDropdowns = document.querySelectorAll('.autocomplete-dropdown');
            const searchContainers = document.querySelectorAll('.search-container');
            
            let clickedInsideSearch = false;
            searchContainers.forEach(container => {
                if (container.contains(e.target)) {
                    clickedInsideSearch = true;
                }
            });
            
            if (!clickedInsideSearch) {
                autocompleteDropdowns.forEach(dropdown => {
                    dropdown.style.display = 'none';
                });
            }
        });

        // 최적화된 페이지 초기화 (Progressive Loading)
        document.addEventListener('DOMContentLoaded', async function() {
            PerformanceMonitor.start('페이지 전체 로드');
            console.log('🚀 최적화된 대시보드 초기화 시작');
           
            try {
                // 1단계: 즉시 스켈레톤 UI 표시 (0ms)
                SkeletonUI.show('overview');
                updatePerformanceIndicator('loading', 'UI 초기화');
                console.log('💀 스켈레톤 UI 표시 완료');
               
                // 2단계: 기본 UI 초기화 (즉시)
                initOverviewStats();
               
                // Overview 필터 기본값을 30일로 설정
                document.querySelectorAll('#overview .chart-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector('#overview .chart-btn[data-days="30"]').classList.add('active');
               
                createOverviewChart(); // 빈 차트 먼저 표시
               
                // 3단계: 백그라운드에서 데이터 로드 시작 (비동기)
                console.log('📡 백그라운드 데이터 로드 시작...');
               
                // 캐시 확인 및 즉시 사용 가능한 데이터가 있다면 먼저 표시
                if (DataCache.isValid('members') && DataCache.members) {
                    console.log('🚀 캐시된 멤버 데이터로 즉시 기본 UI 업데이트');
                    updatePerformanceIndicator('cached', '캐시 사용');
                    const totalMembers = DataCache.members.teamMembers?.length || 0;
                    updateStatsCards(totalMembers, 0, 0); // 기본값으로 먼저 표시
                } else {
                    updatePerformanceIndicator('loading', 'API 호출');
                }
               
                // 4단계: 실제 API 데이터 로드 및 업데이트
                await refreshAllRealData();
               
                // 초기 로드 완료 후 기본 선택 상태 설정 (전체 멤버)
                console.log('초기 로드 완료 후 전체 멤버 기본 선택');
                document.querySelectorAll('.overview-stat-box').forEach(box => {
                    box.classList.remove('selected');
                });
                document.querySelector('.overview-stat-box[data-type="total"]').classList.add('selected');
                currentFilterType = 'total';
                
                // 날짜 입력 필드 변경 시 자동 새로고침 이벤트 리스너 추가
                setupAutoRefreshEvents();
               
                const totalLoadTime = PerformanceMonitor.end('페이지 전체 로드');
                updatePerformanceIndicator('ready', `${totalLoadTime}ms`);
                console.log('✅ 최적화된 대시보드 초기화 완료!');
               
            } catch (error) {
                PerformanceMonitor.end('페이지 전체 로드');
                updatePerformanceIndicator('error', error.message.substring(0, 20));
                console.error('❌ 대시보드 초기화 실패:', error);
               
                // 에러 발생 시에도 기본 UI는 표시
                const errorMessage = `
                    <div style="text-align: center; padding: 50px; color: #ff6b6b;">
                        <h3>⚠️ 데이터 로드 실패</h3>
                        <p>${error.message}</p>
                        <button onclick="location.reload()" style="margin-top: 20px; padding: 10px 20px; background: #4a9eff; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            새로고침
                        </button>
                    </div>
                `;
               
                const overviewSection = document.getElementById('overview');
                if (overviewSection) {
                    overviewSection.innerHTML = errorMessage;
                }
            }
        });

        // 캐시 새로고침 함수 (버튼용)
        function forceCacheRefresh() {
            console.log('🗑️ 캐시 강제 새로고침 시작');
            DataCache.clear();
            location.reload();
        }

        // Refresh 실행 상태 관리 (중복 실행 방지)
        let isRefreshInProgress = false;

        // 진행바 제어 함수들
        function showRefreshProgress() {
            const progressContainer = document.querySelector('.refresh-progress');
            const progressBar = document.querySelector('.refresh-progress-bar');
            if (progressContainer && progressBar) {
                progressContainer.style.display = 'block';
                progressBar.style.width = '0%';
            }
        }

        function updateRefreshProgress(percentage) {
            const progressBar = document.querySelector('.refresh-progress-bar');
            if (progressBar) {
                progressBar.style.width = percentage + '%';
            }
        }

        function hideRefreshProgress() {
            const progressContainer = document.querySelector('.refresh-progress');
            if (progressContainer) {
                progressContainer.style.display = 'none';
            }
        }

        // Refresh 메뉴 클릭 핸들러 (완전 백그라운드 동작)
        async function handleRefreshClick() {
            // 이미 refresh가 진행 중이면 무시
            if (isRefreshInProgress) {
                console.log('🔄 Refresh 이미 진행 중 - 요청 무시');
                return;
            }

            // 진행바 표시
            showRefreshProgress();
            
            // Refresh 시작 (사용자에게는 아무 변화 없음)
            isRefreshInProgress = true;
            
            try {
                console.log('🔄 Refresh 시작 - 백그라운드 데이터 갱신 (사용자 화면 변화 없음)');
                
                // 현재 활성화된 섹션 확인
                const activeSection = document.querySelector('.content-section.active');
                const activeSectionId = activeSection ? activeSection.id : 'overview';
                
                console.log(`현재 활성 섹션: ${activeSectionId}`);
                
                // 백그라운드에서 모든 데이터 새로고침 (병렬 처리)
                console.log('📡 백그라운드 API 데이터 로드 시작...');
                
                // 진행바 단계별 업데이트
                updateRefreshProgress(20);
                await refreshOverviewData();
                updateRefreshProgress(50);
                await refreshMembersData();
                updateRefreshProgress(80);
                await refreshUsageData();
                updateRefreshProgress(90);
                
                // 현재 섹션이 활성화되어 있다면 화면 업데이트
                await updateCurrentSectionDisplay(activeSectionId);
                updateRefreshProgress(100);
                
                console.log('✅ Refresh 완료 - 모든 데이터가 백그라운드에서 갱신됨');
                
            } catch (error) {
                console.error('❌ Refresh 실패:', error);
                // 에러 발생 시에도 사용자 화면에는 변화 없음 (콘솔에만 로그)
            } finally {
                // 진행바 숨기기
                setTimeout(() => {
                    hideRefreshProgress();
                }, 500);
                
                // Refresh 완료 상태로 변경
                isRefreshInProgress = false;
            }
        }

        // Overview 데이터 백그라운드 새로고침
        async function refreshOverviewData() {
            try {
                console.log('📊 Overview 데이터 백그라운드 갱신 중...');
                await updateOverviewWithRealData();
                console.log('✅ Overview 데이터 갱신 완료');
            } catch (error) {
                console.error('❌ Overview 데이터 갱신 실패:', error);
                throw error;
            }
        }

        // Members 데이터 백그라운드 새로고침
        async function refreshMembersData() {
            try {
                console.log('👥 Members 데이터 백그라운드 갱신 중...');
                await updateMembersWithRealData();
                console.log('✅ Members 데이터 갱신 완료');
            } catch (error) {
                console.error('❌ Members 데이터 갱신 실패:', error);
                throw error;
            }
        }

        // Usage 데이터 백그라운드 새로고침 (화면 변화 없이 캐시만 갱신)
        async function refreshUsageData() {
            try {
                console.log('📈 Usage 데이터 백그라운드 갱신 중 (화면 변화 없음)...');
                
                // 날짜 범위 계산
                const dateRange = getDateRange(30);
                
                // API 데이터만 가져와서 캐시에 저장 (화면 업데이트 없음)
                const [membersData, eventsData, usageData, spendingData] = await Promise.all([
                    getTeamMembers(),
                    getFilteredEvents(dateRange.startDate, dateRange.endDate),
                    getUsageData(dateRange.startDate, dateRange.endDate),
                    getTeamSpendingData()
                ]);
                
                // 캐시에만 저장하고 화면은 업데이트하지 않음
                console.log('💾 Usage 데이터를 캐시에 저장 (화면 업데이트 안함)');
                
                // 전역 변수에 데이터 저장 (화면 업데이트 함수들 호출하지 않음)
                // 이렇게 하면 데이터는 최신으로 유지되지만 화면은 변경되지 않음
                
                console.log('✅ Usage 데이터 백그라운드 갱신 완료 (캐시만 업데이트)');
            } catch (error) {
                console.error('❌ Usage 데이터 갱신 실패:', error);
                throw error;
            }
        }

        // 현재 섹션 화면 업데이트 (백그라운드 갱신 후)
        async function updateCurrentSectionDisplay(activeSectionId) {
            try {
                console.log(`🖥️ 현재 섹션 화면 업데이트: ${activeSectionId}`);
                switch(activeSectionId) {
                    case 'overview':
                        await updateOverviewWithCurrentFilter();
                        break;
                    case 'members':
                        // Members는 이미 refreshMembersData()에서 갱신됨
                        // 추가 화면 업데이트 없음
                        break;
                    case 'usage':
                        // Usage는 백그라운드에서만 데이터 갱신됨
                        // 화면 업데이트 하지 않음 (사용자가 보고 있는 화면 유지)
                        console.log('Usage 섹션: 화면 업데이트 안함 (백그라운드 갱신만)');
                        break;
                    case 'settings':
                        // Settings는 별도 API 데이터가 없음
                        break;
                }
                console.log(`✅ ${activeSectionId} 섹션 화면 업데이트 완료`);
            } catch (error) {
                console.error(`❌ ${activeSectionId} 섹션 화면 업데이트 실패:`, error);
            }
        }

        // 자동 새로고침 이벤트 설정
        function setupAutoRefreshEvents() {
            console.log('자동 새로고침 이벤트 리스너 설정 중...');
            
            // Overview 날짜 입력 필드
            const overviewStartDate = document.getElementById('start-date');
            const overviewEndDate = document.getElementById('end-date');
            
            if (overviewStartDate && overviewEndDate) {
                overviewStartDate.addEventListener('change', debounce(async () => {
                    if (overviewStartDate.value && overviewEndDate.value) {
                        console.log('Overview 시작 날짜 변경됨 - 자동 새로고침');
                        await applyDateFilter();
                    }
                }, 500));
                
                overviewEndDate.addEventListener('change', debounce(async () => {
                    if (overviewStartDate.value && overviewEndDate.value) {
                        console.log('Overview 종료 날짜 변경됨 - 자동 새로고침');
                        await applyDateFilter();
                    }
                }, 500));
            }
            
            // Usage 날짜 입력 필드
            const usageStartDate = document.getElementById('usage-start-date');
            const usageEndDate = document.getElementById('usage-end-date');
            
            if (usageStartDate && usageEndDate) {
                usageStartDate.addEventListener('change', debounce(async () => {
                    if (usageStartDate.value && usageEndDate.value) {
                        console.log('Usage 시작 날짜 변경됨 - 자동 새로고침');
                        await applyUsageDateFilter();
                    }
                }, 500));
                
                usageEndDate.addEventListener('change', debounce(async () => {
                    if (usageStartDate.value && usageEndDate.value) {
                        console.log('Usage 종료 날짜 변경됨 - 자동 새로고침');
                        await applyUsageDateFilter();
                    }
                }, 500));
            }
            
            console.log('자동 새로고침 이벤트 리스너 설정 완료');
        }

        // 디바운스 함수 (연속 호출 방지)
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        document.addEventListener('DOMContentLoaded', function() {
            // 기본 설정 후
            setTimeout(async () => {
                createOverviewChart();
                console.log('=== 페이지 로드 시 자동 실제 API 데이터 새로고침 시작 ===');
                await refreshAllRealData(); // 자동 새로고침
            }, 100);
        });

    </script>
</body>
</html>